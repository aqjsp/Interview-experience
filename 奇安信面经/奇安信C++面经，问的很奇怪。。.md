来源：https://www.nowcoder.com/discuss/544970867139211264

### 1、线程模型怎么搭配epoll进行使用？

1. 选择适当的线程模型：
   - 多线程模型：在多线程模型中，每个线程负责处理一个或多个客户端连接。当新的客户端连接到服务器时，服务器会将连接分发给空闲线程，每个线程使用`epoll`来监听和处理它所负责的连接。
   - 线程池模型：线程池中的每个线程都使用`epoll`来监听一组连接。当新的连接到达时，主线程将其分发给线程池中的一个线程。这种方式可以节省线程创建和销毁的开销。
2. 主线程用于接受新的客户端连接，然后将连接套接字分发给工作线程。主线程也可以用一个`epoll`对象来监听新连接的到达。
3. 每个工作线程都有自己的`epoll`对象，它使用`epoll`来监听多个连接。工作线程可以采用阻塞或非阻塞的方式从`epoll`中获取就绪事件并处理它们。
4. 在每个工作线程内，使用`epoll`来监控多个连接的事件，如读、写等。当有事件发生时，线程处理这些事件。处理过程通常包括数据的读取和写入，以及相应的业务逻辑。
5. 在多线程模型中，需要确保线程之间的并发访问是安全的。使用互斥锁、条件变量等来实现线程间的同步，以避免竞态条件和数据不一致性问题。
6. 线程模型需要正确地管理线程的生命周期和资源。这包括线程的创建、销毁和线程池的管理。

### 2、怎么理解io多路复用？

I/O多路复用（IO Multiplexing）是一种用于处理多个I/O通道的技术，它使一个进程能够同时监视多个文件描述符（通常是套接字或文件），并等待其中任何一个变为可读（或可写）时立即作出相应的处理。这样，一个进程就可以有效地管理多个I/O通道，而无需为每个I/O通道创建一个单独的线程或进程。

I/O多路复用的特点：

1. 单线程管理多通道：通过使用I/O多路复用，单个线程可以同时管理多个I/O通道，无需为每个通道创建额外的线程。这可以减小系统开销，降低了多线程或多进程模型的复杂性。
2. 非阻塞：I/O多路复用通常与非阻塞I/O配合使用。它监视多个通道的状态，当有通道就绪时，进程会立即得到通知。这样，进程可以选择性地处理就绪通道，而不会阻塞在等待I/O操作完成的过程中。
3. 高并发性：I/O多路复用适用于高并发的场景，如网络服务器，因为它能够同时管理大量的客户端连接，而无需为每个连接创建一个线程。这降低了系统资源的消耗。
4. 一种事件驱动模型：I/O多路复用是一种事件驱动的编程模型。程序会不断等待多个I/O事件的发生，然后响应这些事件，而不是按照固定的顺序轮询I/O通道。
5. 适用于异步通信：I/O多路复用也适用于异步通信，其中程序不需要等待数据准备就绪。它只需等待通道变为可读（或可写），然后执行相应的操作。

### 3、epoll的边沿触发和水平触发？

1. 边沿触发（ET）：
   - `epoll`采用边沿触发模式时，只有在文件描述符状态发生变化的瞬间才会触发事件。这表示如果文件描述符从无数据变为有数据（例如套接字缓冲区中有新数据到达），或者从有数据变为空，`epoll`将通知相应事件。
   - ET触发要求处理程序必须立即对文件描述符进行读取或写入操作，以消耗这些新的数据。如果没有处理完数据，`epoll`不会再次触发该文件描述符，即使它仍然具有未读取的数据。
2. 水平触发（LT）：
   - `epoll`采用水平触发模式时，只要文件描述符处于可读或可写状态，`epoll`就会不断地触发事件。这意味着处理程序需要在文件描述符就绪时进行数据处理，但如果它没有处理完所有数据，`epoll`会在下一次等待中再次触发该事件。
   - 水平触发模式下，处理程序必须自行管理文件描述符的状态，以避免不必要的触发。如果不读取已准备好的数据，`epoll`将保持触发状态。

### 4、你两种模式都使用过，那两种使用起来有什么区别吗？

1. 触发方式:
   - ET模式：只在状态发生变化时触发，只通知一次，需要程序立即处理。不处理的话，下次可能就错过了。
   - LT模式：只要状态是就绪的，就会不断触发，直到状态变为非就绪。
2. 效率:
   - ET模式通常会比LT模式效率更高，因为它减少了触发次数。在高并发环境下，ET模式对系统资源的消耗可能较小。
   - LT模式则需要更频繁地处理事件触发，可能会导致更多的系统调用。
3. 处理难度:
   - ET模式需要更小心的处理，因为事件只通知一次，需要在非阻塞的情况下处理完。这对于高性能要求的情况可能需要更精细的控制。
   - LT模式相对容易处理，因为可以在多次触发时持续处理，不容易错过数据。
4. 阻塞问题:
   - 在ET模式下，如果事件没有被完全处理，文件描述符可能会一直被触发，因此可能会引发大量的事件触发导致程序阻塞。
   - 在LT模式下，处理未完全的事件后，文件描述符状态会变为非就绪，避免了频繁触发。
5. 代码复杂性:
   - 使用ET模式需要更多的代码来确保就绪状态及时处理，处理未完成的数据，避免丢失数据。
   - 使用LT模式下的代码可能相对简单，不需要太多处理。

### 5、有观察过这两种的区别从连接到传数据？

1. 连接时触发:
   - ET模式：当客户端与服务器建立连接时，只触发一次`EPOLLIN`事件。如果不立即接收数据，可能会错过数据。
   - LT模式：连接建立时会触发`EPOLLIN`事件，并且会持续触发，直到应用程序处理。
2. 传输数据时触发:
   - ET模式：只有在状态发生变化时触发，例如套接字由不可读变为可读时触发。需要确保一次性处理完所有可读数据，否则下次不会再次触发。
   - LT模式：只要套接字是可读的，就会持续触发，无论你是否完全处理了数据。在这种情况下，您只需处理当前可读的数据。
3. 阻塞问题:
   - ET模式：如果未读取所有可用数据并且未设置为非阻塞套接字，则可能导致套接字一直处于可读状态，事件不断触发，应用程序可能会阻塞。
   - LT模式：如果没有将套接字设置为非阻塞，并且未读取所有数据，则仍然会触发，但不会导致阻塞。
4. 性能和效率:
   - ET模式：通常效率更高，因为它减少了不必要的触发次数，但需要更小心处理。
   - LT模式：可能需要更频繁地处理事件触发，因此可能在高并发场景下效率稍低。

### 6、有观察过HTTP的包吗？

可以使用网络抓包工具（如Wireshark）来捕获和分析HTTP包，以深入了解网络通信过程和排查问题。

以下是一些观察 HTTP 包时可以获得的信息：

1. 请求和响应头部信息： HTTP 包中包含请求和响应的头部，其中包括各种元数据，如 User-Agent、Host、Cookie、Content-Type 等。这些头部提供了关于请求或响应的重要信息。
2. 请求方法和URL： 您可以查看 HTTP 请求的方法（GET、POST、PUT 等）以及请求的 URL，从而了解客户端请求的具体内容。
3. 状态码： HTTP 响应包中包含状态码（如200 OK、404 Not Found、500 Internal Server Error），这些状态码提供了有关响应状态的信息。
4. Cookie 和 Session： 您可以查看请求和响应中的 Cookie 信息，了解关于用户会话管理的信息。
5. 响应体内容： 您可以查看 HTTP 响应包的主体内容，例如 HTML、JSON、XML 等。这有助于分析网页的内容或应用程序的数据。
6. 连接状态： 您可以查看连接建立和断开的过程，包括三次握手和四次挥手的情况。
7. 重定向： 如果服务器对请求进行了重定向，您可以查看 HTTP 头部中的重定向信息，了解新的目标 URL。
8. 压缩： 您可以查看是否启用了数据压缩，以了解数据传输时是否使用了压缩算法。
9. 安全： 您可以查看是否使用了 HTTPS 协议，以确保数据在传输过程中得到加密保护。

### 7、有看过http的报文的头吗？

HTTP 头部通常包括以下元素：

1. 请求方法： 这部分指定了客户端请求的操作类型，例如 GET、POST、PUT、DELETE 等。
2. URL： 这部分包含了客户端请求的资源的路径，通常以斜杠开头，如 `/path/to/resource`。
3. 协议版本： 这是指定使用的 HTTP 协议版本，如 HTTP/1.1。
4. 请求头字段： 请求头字段包含了多个键值对，用于传递关于请求的附加信息。常见的请求头字段包括：
   - User-Agent：标识发送请求的用户代理（通常是浏览器）。
   - Host：指定服务器主机名和端口号。
   - Accept：指定客户端接受的内容类型。
   - Cookie：包含与请求关联的 Cookie 数据。
   - Authorization：用于身份验证的凭据，如用户名和密码。
5. 响应状态码： 这部分指示了服务器对请求的处理结果，如 200 OK、404 Not Found、500 Internal Server Error 等。
6. 响应头字段： 响应头字段包含了服务器返回的附加信息，类似于请求头字段。常见的响应头字段包括：
   - Content-Type：指定响应主体的内容类型，如 text/html、application/json 等。
   - Server：标识响应的服务器软件。
   - Set-Cookie：包含要在客户端上设置的 Cookie 数据。
   - Location：用于重定向响应。
7. 主体内容： 这部分包含了请求或响应的实际数据，如 HTML 页面、JSON 数据等。

### 8、除了Get和post其他方法见过吗？

1. HEAD： HEAD 方法与 GET 方法类似，但不返回响应主体内容。它用于获取与请求资源相关的元数据，如响应头字段，而无需获取实际数据。通常用于检查资源是否存在或获取资源的元信息，以节省带宽和时间。
2. PUT： PUT 方法用于将请求的数据存储到指定的 URL。它通常用于上传文件或更新特定资源。如果资源不存在，服务器可以创建一个新资源；如果资源已存在，服务器可以更新它。
3. DELETE： DELETE 方法用于从指定 URL 删除资源。它允许客户端请求服务器删除指定资源。删除操作的可用性和行为取决于服务器的实现。
4. OPTIONS： OPTIONS 方法用于请求有关目标 URL 的通信选项信息。服务器会告诉客户端支持哪些 HTTP 方法、头字段和其他通信选项。这对于确定服务器的功能非常有用。
5. PATCH： PATCH 方法用于局部更新资源。它请求服务器仅更新目标资源的一部分，而不是整个资源。这有助于减少数据传输和提高效率。
6. TRACE： TRACE 方法用于对目标服务器执行一个请求，目标服务器将该请求返回给客户端。TRACE 通常用于测试和调试，以查看请求在传输过程中的变化。

### 9、Get和Post有什么区别吗？

1. 参数传递位置：
   - GET： 参数以查询字符串的形式附加到 URL 的末尾，例如 `http://example.com/resource?param1=value1&param2=value2`。
   - POST： 参数通常包含在请求的主体中，而不会附加到 URL 中，因此参数不会在 URL 中可见。
2. 请求长度：
   - GET： 由于参数位于 URL 中，GET 请求通常有长度限制，因为不同浏览器和服务器都对 URL 长度有限制。通常不适合传输大量数据。
   - POST： 由于参数在请求主体中，POST 请求没有固定的长度限制，因此更适合传输大量数据。
3. 安全性：
   - GET： GET 请求参数可见于 URL，因此不适合传输敏感信息，如密码或个人数据，因为它们可能会被记录在浏览器的历史记录、服务器日志等地方。
   - POST： POST 请求的参数在请求主体中，不会公开显示在 URL 上，更适合传输敏感信息，因为数据不容易被窥探。
4. 幂等性：
   - GET： GET 请求通常是幂等的，即多次相同的 GET 请求不会产生不同的效果。例如，多次请求同一个 URL 应该返回相同的结果。
   - POST： POST 请求通常不是幂等的，因为多次相同的 POST 请求可能会产生不同的效果。例如，多次提交一个订单可能会导致多次创建订单。
5. 缓存：
   - GET： GET 请求通常可以被浏览器缓存，以提高性能。如果请求相同的 URL，浏览器可能会返回缓存的响应而不会发出新请求。
   - POST： POST 请求通常不会被缓存，因为它们通常用于对服务器产生副作用的操作，如提交表单。
6. 用途：
   - GET： 通常用于从服务器获取数据，如请求网页、搜索、过滤和排序数据等。
   - POST： 通常用于向服务器提交数据，如提交表单、上传文件、执行操作等。

### 10、URL组成，uri是什么？

URL（Uniform Resource Locator）是用于标识和定位资源的通用标识符。它由多个组成部分构成，包括协议、主机、端口、路径和查询字符串等。URI（Uniform Resource Identifier）是一个更通用的概念，它不仅包括 URL，还包括 URN（Uniform Resource Name），用于标识资源而不涉及其位置。URI 是 URL 的超集。

URL 的主要组成部分：

1. 协议（Protocol）： 它指定了访问资源所需的协议，例如 HTTP、HTTPS、FTP、file 等。协议通常以冒号（:）结尾。
2. 主机（Host）： 主机标识了资源所在的服务器或计算机。主机通常以域名或 IP 地址表示，可以包括端口号（例如，www.example.com:80）。
3. 端口（Port）： 端口号指定了服务器上用于与客户端通信的端口。它通常是可选的，如果未明确指定，默认端口将根据协议自动确定。
4. 路径（Path）： 路径标识了资源在服务器上的位置。它可以包括目录和文件名，以斜杠（/）分隔。
5. 查询字符串（Query String）： 查询字符串包含了用于请求资源的参数和值，通常以问号（?）开头，参数和值之间以等号（=）分隔，不同参数之间以和号（&）分隔。
6. 片段标识符（Fragment Identifier）： 片段标识符用于标识资源中的特定片段或位置。它通常以井号（#）开头。

### 11、线程池用到那些线程间通讯？

1. 任务队列（Task Queue）： 线程池通常会维护一个任务队列，其中存储了待执行的任务。当线程池中的线程空闲时，它们会从任务队列中获取任务并执行。线程池中的线程之间可以通过任务队列共享任务，这通常需要采用同步机制，如互斥锁，以确保任务的正确分发。
2. 线程同步： 在执行任务时，线程池中的线程可能需要进行线程同步，以避免竞争条件和协调任务的执行。常见的线程同步机制包括互斥锁、条件变量、信号量等。
3. 通知机制： 当任务队列中有新任务可用时，线程池中的线程需要被通知以执行任务。这通常需要使用条件变量或信号量等机制。
4. 异常处理： 线程池中的线程在执行任务时可能会遇到异常情况。线程池需要一种方式来捕获并处理这些异常，通常通过记录日志或向主线程报告异常。
5. 线程池状态管理： 线程池通常具有不同的状态，如运行、暂停、停止等。线程池中的线程需要知道当前线程池的状态以确定它们是否应该执行任务。
6. 结果返回： 在某些情况下，任务执行后需要将结果返回给请求线程或其他线程。线程池中的线程可能需要使用共享的数据结构来传递结果。
7. 任务优先级： 线程池中的任务可能具有不同的优先级。线程池需要一种方式来确定哪些任务应该首先执行。

### 12、C++强制类型转化？

1. 静态转换（Static Cast）:

   - 静态转换是最常见的类型转换，也是最不安全的。它基本上告诉编译器将一个类型转换为另一个类型。

   - 静态转换没有运行时检查，因此需要谨慎使用，以确保类型兼容性。它通常用于较为明显的类型转换。

```C++
double x = 10.5;
int y = static_cast<int>(x);
```

2. 动态转换（Dynamic Cast）:

   - 动态转换用于类层次结构中，用于在运行时检查和转换指向基类的指针或引用是否指向派生类的对象。

   - 它需要基类有虚函数，以便进行运行时类型检查。如果不满足条件，转换将返回空指针或引发`std::bad_cast`异常。

```C++
class Base { virtual void foo() {} };
class Derived : public Base { /* ... */ };

Base* basePtr = new Derived;
Derived* derivedPtr = dynamic_cast<Derived*>(basePtr);
```

3. 常量转换（Const Cast）:

常量转换用于添加或删除`const`属性。它主要用于允许更改变量的`const`性质，但也需要谨慎使用，因为它可能引发未定义行为。

```C++
const int x = 5;
int* y = const_cast<int*>(&x);
```

4. 重新解释转换（Reinterpret Cast）:

- 重新解释转换是最危险的类型转换，通常用于将一种类型的指针或引用解释为完全不同的类型。
- 这种类型的转换几乎不进行任何类型检查，因此非常不安全。它通常用于处理底层的二进制数据。

```C++
int x = 42;
double y = reinterpret_cast<double*>(&x);
```

### 13、C++中的堆和栈的区别？

1. 分配方式:
   - 栈：栈是一种自动分配和释放内存的数据结构，它遵循"后进先出"（LIFO）原则。当你声明一个局部变量时，该变量存储在栈上。函数的参数和局部变量也存储在栈上。栈的分配和释放是自动的，由编译器管理。
   - 堆：堆是一种手动分配和释放内存的数据结构。在堆上分配内存需要使用`new`或`malloc`等函数，释放内存则需要使用`delete`或`free`。堆上的内存不会自动释放，必须手动管理。
2. 存储内容:
   - 栈：栈主要存储局部变量、函数参数和函数调用的上下文。它的存储生命周期通常是有限的，当超出其作用域时，内存会自动释放。
   - 堆：堆主要用于存储动态分配的对象和数据结构。它的存储生命周期没有那么明确，需要手动释放。
3. 生命周期:
   - 栈：栈上的变量生命周期与其作用域（通常是一个函数的执行）相对应。一旦超出作用域，栈上的变量将自动销毁。
   - 堆：堆上的内存生命周期由程序员控制。在程序员显式释放内存之前，内存将一直存在。
4. 分配速度:
   - 栈：由于栈上的内存分配和释放是自动管理的，通常比堆更快。
   - 堆：堆上的内存分配和释放需要较多的开销，通常比较慢。
5. 大小限制:
   - 栈：栈的大小通常受到限制，因为它由操作系统管理，可以很小，通常在几MB以内。
   - 堆：堆的大小可以较大，受到系统资源的限制，通常比栈要大得多。
6. 数据访问:
   - 栈：栈上的数据访问速度较快，因为它是线性存储，访问局部变量通常只需要一次寻址操作。
   - 堆：堆上的数据访问速度较慢，因为它是散乱存储，需要进行额外的寻址操作。

### 14、指针和引用的区别？

1. 定义和初始化:
   - 指针：指针是一个变量，存储了一个内存地址。你可以使用`*`操作符来定义和初始化指针。例如：`int* ptr = &myVariable;`
   - 引用：引用是一个别名，它在声明时需要和一个已存在的变量绑定在一起。例如：`int& ref = myVariable;`
2. Null值:
   - 指针：指针可以具有空指针值（`nullptr`或`NULL`），表示不指向任何有效内存。
   - 引用：引用不能绑定到空值，必须在初始化时与一个有效的对象关联。
3. 重新赋值:
   - 指针：指针可以被重新赋值，指向不同的内存地址。
   - 引用：引用一旦绑定，不能再与其他对象重新绑定，它始终引用相同的对象。
4. 内存访问:
   - 指针：通过解引用操作符`*`可以访问指针所指向的内存。指针可以用于遍历数组等复杂操作。
   - 引用：引用的访问方式类似于变量，没有额外的操作符。引用通常用于传递函数参数或创建别名。
5. 语法:
   - 指针：指针需要使用`*`来声明和解引用，语法较为复杂。
   - 引用：引用使用`&`来声明，对使用者来说更加透明和简单。
6. 目的:
   - 指针：指针通常用于实现数据结构、动态内存分配和高级操作，例如在函数中修改参数的值。
   - 引用：引用通常用于简化函数参数传递和提供更直观的语法，不需要使用指针的复杂性。
7. 空值检查:
   - 指针：需要显式检查指针是否为`nullptr`或`NULL`，否则可能引发空指针异常。
   - 引用：不需要空值检查，因为引用在初始化时必须绑定到有效对象。
8. 传递方式:
   - 指针：通过传值或传递指针，函数可以修改指针所指的内存。
   - 引用：通过传引用，函数可以修改引用所绑定的对象的值。

### 15、关键字static的使用？

1. 静态变量：`static` 可以用于变量，使其成为静态变量，也称为类变量。静态变量与类相关联而不是与对象相关联，它们只有一个实例，无论创建多少类的对象。

```C++
class MyClass {
public:
    static int myStaticVar; // 静态变量
};

int MyClass::myStaticVar = 0; // 初始化静态变量

int main() {
    MyClass obj1;
    MyClass obj2;
    obj1.myStaticVar = 10; // 这会影响所有 MyClass 对象的 myStaticVar 值
    std::cout << obj2.myStaticVar; // 输出 10
    return 0;
}
```

2. 静态函数：`static` 关键字还可以用于函数，使其成为静态函数。静态函数只能访问静态变量或其他静态函数，不依赖于对象的状态。

```C++
class MyClass {
public:
    static void myStaticFunction() {
        std::cout << "This is a static function." << std::endl;
    }
};

int main() {
    MyClass::myStaticFunction(); // 调用静态函数
    return 0;
}
```

3. 局部静态变量：`static` 关键字还可以用于局部变量，使其成为局部静态变量。局部静态变量只在首次调用函数时初始化，之后保留其值，直到程序结束。

```C++
void myFunction() {
    static int count = 0; // 局部静态变量
    count++;
    std::cout << "Count: " << count << std::endl;
}

int main() {
    myFunction(); // 输出 Count: 1
    myFunction(); // 输出 Count: 2
    return 0;
}
```

4. 静态成员变量：`static` 还可以用于类的成员变量，使其成为静态成员变量。这些变量与类相关联，而不是与对象相关联，它们被所有类的对象所共享。

```C++
class MyClass {
public:
    static int count; // 静态成员变量
    MyClass() {
        count++;
    }
};

int MyClass::count = 0; // 初始化静态成员变量

int main() {
    MyClass obj1;
    MyClass obj2;
    std::cout << MyClass::count; // 输出 2
    return 0;
}
```

### 16、gdb使用过吗，调试过多线程吗？

给大家一个参考步骤：

在使用 GDB 调试多线程应用程序时，常见的操作：

1. 启动程序：使用 `gdb` 命令后跟随可执行文件的名称来启动 GDB。例如：`gdb myprogram`。
2. 设置断点：使用 `break` 或 `b` 命令来在代码中设置断点。例如，`b main` 可以在 `main` 函数开始时设置断点。
3. 运行程序：使用 `run` 命令启动程序执行。
4. 控制程序执行：可以使用 `continue` 继续程序的执行，使用 `next` 逐行执行，使用 `step` 进入函数调用，或使用 `finish` 退出函数调用。
5. 查看线程：使用 `info threads` 命令来查看当前程序中的所有线程。
6. 切换线程：使用 `thread <ID>` 命令来切换到指定线程。例如，`thread 2` 将切换到第二个线程。
7. 查看线程栈：使用 `backtrace` 或 `bt` 命令来查看线程的调用栈。
8. 观察变量：使用 `print` 或 `p` 命令来查看变量的值，例如 `p myVar`。
9. 监视表达式：使用 `watch` 命令来监视变量或表达式的值，当其值发生变化时，GDB 会中断程序执行。
10. 分析线程问题：使用 `thread apply <ID> <command>` 命令来在特定线程上执行命令，以便分析特定线程的问题。
11. 继续执行：使用 `continue` 命令来继续程序的执行，直到下一个断点或异常。
12. 退出 GDB：使用 `quit` 命令退出 GDB。

### 17、Linux上ping命令能确认哪些内容？

1. 目标主机是否可达： `ping` 命令用于测试与目标主机之间的连通性。如果目标主机可达，它将返回响应；否则，它将显示错误消息。
2. 网络连接质量： `ping` 命令会测量往返时间（Round-Trip Time，RTT），也就是发送 ICMP 报文到目标主机并接收响应所需的时间。通过观察 RTT，可以大致了解网络连接的质量。较低的 RTT 表示较好的连接质量。
3. TTL（Time to Live）： ICMP 报文中包含 TTL 字段，`ping` 命令会将 TTL 递减。当 TTL 达到 0 时，主机会发送 ICMP 超时消息，这允许您确定到达目标主机所需的跃点数。
4. 数据包丢失率： `ping` 命令会在一定时间内发送多个 ICMP 回显请求（ping 请求），并计算丢失的请求数量。通过观察丢失率，您可以了解网络上是否存在数据包丢失问题。
5. 域名解析： 如果您使用主机名而不是 IP 地址来执行 `ping`，则 `ping` 命令会首先执行域名解析以获取目标主机的 IP 地址。
6. 连续性测试： `ping` 命令默认情况下会持续发送 ICMP 请求，直到手动中止。这使您能够进行连续性测试，以确保目标主机在一段时间内保持连通。
7. RTT统计信息： `ping` 命令通常会在测试结束后显示 RTT 的统计信息，如最小 RTT、最大 RTT、平均 RTT 等。这些信息提供了关于网络连接性能的更全面的了解。
8. 探测主机活动： 通过定期发送 ICMP 请求，`ping` 命令可用于探测主机的活动状态。这在监控和故障排除中非常有用。

### 18、Ping的底层实现？

`ping` 命令的底层实现通常使用 ICMP（Internet Control Message Protocol）协议。ICMP 是一种网络层协议，用于在 IP 网络上传输控制消息。`ping` 命令使用 ICMP Echo 请求和 Echo 回复消息来测试主机的连通性。

 `ping` 命令的底层实现方式：

1. 发送 ICMP Echo 请求： 当您在终端中执行 `ping` 命令，操作系统会创建一个 ICMP Echo 请求消息（ping 请求）。这个消息包括目标主机的 IP 地址和一个标识符（通常是进程 ID），以便将响应与请求关联。
2. 封装 ICMP 消息： 操作系统封装 ICMP Echo 请求消息为 IP 数据包。这个 IP 数据包包括源 IP 地址和目标 IP 地址，并由操作系统的网络协议栈处理。
3. 发送 ICMP 数据包： 操作系统通过网络接口将封装后的 ICMP 数据包发送到网络上，以便达到目标主机。
4. 目标主机的 ICMP 响应： 目标主机接收到 ICMP Echo 请求后，将生成 ICMP Echo 回复消息（ping 响应）。这个响应消息包括与请求相同的标识符以及序列号，以便进行匹配。
5. 封装 ICMP 响应消息： 目标主机将 ICMP Echo 回复消息封装为 IP 数据包，并将其发送回发起请求的主机。
6. 接收 ICMP 响应： 发起请求的主机接收到 ICMP Echo 回复消息。`ping` 命令会计算 RTT（Round-Trip Time），也就是请求发送到响应接收之间的时间。
7. 显示结果： `ping` 命令将收到的 ICMP 响应解析，并显示有关主机连通性、RTT、丢包率等的信息。通常，`ping` 命令还会提供统计信息，如最小 RTT、最大 RTT 和平均 RTT。

### 19、C++中map，如果key不存在，使用[]形式遍历能成功吗？

在 C++ 的 `std::map` 中，使用`[]` 运算符访问一个不存在的键会导致该键被插入到 `map` 中，并关联一个默认值。这是 `std::map` 的特性之一。如果你使用 `[]` 访问一个不存在的键，它将插入一个键-值对，其中键是你所指定的键，而值是键类型的默认值。

示例：

```C++
#include <iostream>
#include <map>

int main() {
    std::map<int, std::string> myMap;
    
    myMap[1] = "One";  // 插入键1和值"One"
    
    std::cout << myMap[1] << std::endl;  // 输出"One"
    std::cout << myMap[2] << std::endl;  // 输出空字符串，因为键2不存在

    return 0;
}
```

`myMap[1]` 和 `myMap[2]` 都使用 `[]` 运算符进行访问。由于键2在 `myMap` 中不存在，所以它被插入，并且与一个空字符串（`std::string` 的默认构造函数生成的值）关联。

### 20、Tcp编程常用的api？

1. socket()： 用于创建套接字。它返回一个文件描述符，表示一个套接字对象。您可以指定套接字的地址族（通常是 AF_INET 用于 IPv4 或 AF_INET6 用于 IPv6）、套接字类型（SOCK_STREAM 用于 TCP）和协议。
2. bind()： 用于将套接字绑定到本地地址和端口。这通常在服务器端使用，以便监听来自客户端的连接请求。
3. listen()： 用于将套接字设置为监听状态，以接受传入的连接请求。通常在服务器端使用。
4. accept()： 用于接受传入的连接请求并创建一个新的套接字来处理连接。它返回一个新的文件描述符，该描述符用于与连接的客户端通信。
5. connect()： 用于在客户端建立与服务器的连接。
6. send() 和 recv()： 用于发送和接收数据。您可以使用这些函数在套接字之间传递数据。
7. read() 和 write()： 与 send() 和 recv() 类似，用于读取和写入数据。
8. close()： 用于关闭套接字连接。
9. shutdown()： 用于关闭套接字的一侧（读或写），通常在双向通信时使用。

这些 API 都可以在 `<sys/socket.h>` 头文件中找到。

### 21、tcp三次握手、四次挥手？

三次握手（TCP 连接建立）

1. 客户端发送 SYN： 客户端想要与服务器建立连接，首先向服务器发送一个 TCP 报文，该报文的标志位（flags）中包含 SYN（同步）标志。此时，客户端进入 SYN_SENT 状态。
2. 服务器回应 SYN-ACK： 服务器收到客户端的 SYN 报文后，需要确认建立连接。服务器向客户端发送一个带有 SYN 和 ACK（确认）标志的报文。此时，服务器进入 SYN_RCVD 状态。
3. 客户端确认 ACK： 客户端接收到服务器的 SYN-ACK 报文后，会向服务器发送一个带有 ACK 标志的报文，用于确认连接的建立。此时，客户端和服务器都进入 ESTABLISHED 状态，连接已建立，双方可以开始传输数据。

四次挥手（TCP 连接断开）

1. 客户端发送 FIN： 客户端决定关闭连接时，向服务器发送一个带有 FIN（终止）标志的报文，表示不再发送数据。客户端进入 FIN_WAIT_1 状态。
2. 服务器回应 ACK： 服务器接收到客户端的 FIN 报文后，向客户端发送一个带有 ACK 标志的报文，确认接收到 FIN 报文。服务器进入 CLOSE_WAIT 状态，客户端仍可发送数据。
3. 服务器发送 FIN： 服务器决定关闭连接时，向客户端发送一个带有 FIN 标志的报文，表示服务器不再发送数据。服务器进入 LAST_ACK 状态。
4. 客户端回应 ACK： 客户端接收到服务器的 FIN 报文后，向服务器发送一个 ACK 报文，确认接收到 FIN 报文。客户端进入 TIME_WAIT 状态。在客户端进入 TIME_WAIT 状态后，它将等待一段时间，确保服务器收到 ACK，并在此期间不接受来自服务器的新连接请求。这个等待时间称为 TIME_WAIT 等待时间。

### 22、输入一个url会出现那些过程？

1. URL 解析： 浏览器首先解析输入的 URL，将其分解为以下主要部分：
   - 协议（例如，HTTP、HTTPS）
   - 主机（例如，www.xxx.com）
   - 端口号（如果未显式指定，则使用默认端口，如 HTTP 的 80 或 HTTPS 的 443）
   - 路径（指定要访问的资源路径，如 /path/to/resource）
   - 查询字符串（包含请求参数，如 ?param1=value1&param2=value2）
   - 片段标识符（用于指定页面内的特定位置，如 #section1）
2. DNS 解析： 浏览器需要将主机名解析为 IP 地址，以便建立连接。如果 DNS 缓存中没有相应的解析结果，浏览器会发出 DNS 查询请求，将主机名转换为 IP 地址。
3. 建立 TCP 连接： 浏览器使用协议（HTTP 或 HTTPS）和解析后的 IP 地址以及可能的端口号，与服务器建立 TCP 连接。这是通过三次握手的过程来完成的，如前面所述。
4. 发送 HTTP 请求： 一旦建立了 TCP 连接，浏览器将发送一个 HTTP 请求，其中包括请求的方法（GET、POST 等）、路径、主机、查询字符串、请求头和可能的请求正文（对于 POST 请求）。
5. 服务器处理请求： 服务器接收到浏览器发送的请求后，会根据请求的内容和路径来执行相应的操作。这可能包括访问数据库、处理请求参数、生成响应等。
6. 服务器发送响应： 服务器会生成 HTTP 响应，其中包括响应状态码、响应头、响应正文和其他相关信息。
7. 浏览器接收响应： 浏览器接收来自服务器的 HTTP 响应，并开始处理响应数据。这通常包括解析 HTML、CSS 和 JavaScript，并加载其他资源，如图像、样式表和脚本文件。
8. 呈现页面： 浏览器呈现 HTML 内容，构建页面的 DOM（文档对象模型），应用 CSS 样式并执行 JavaScript 以添加交互性。
9. 显示页面： 最终，浏览器将已呈现的页面内容显示在用户的屏幕上。
10. 处理用户交互： 用户可以与页面进行交互，包括点击链接、填写表单、滚动页面等。
11. 保持连接（可选）： 如果页面包含外部资源，如图像或嵌入的内容，浏览器可能会继续保持与服务器的连接，以便在需要时获取这些资源。
12. 断开连接： 一旦页面被完全加载和显示，浏览器会在不再需要连接时断开与服务器的连接。

### 23、http和https的区别？

1. 安全性：
   - HTTP： HTTP 是一种不安全的协议，数据在传输过程中是明文的，容易被中间人攻击者截获和窥视。
   - HTTPS： HTTPS 使用 SSL/TLS（Secure Sockets Layer/Transport Layer Security）协议来加密数据传输，从而提供安全性。数据在传输时经过加密，使其难以被窃取或篡改。
2. 端口：
   - HTTP： HTTP 默认使用端口 80 进行通信。
   - HTTPS： HTTPS 默认使用端口 443 进行通信。
3. URL 前缀：
   - HTTP： HTTP 的 URL 以 "http://" 开头。
   - HTTPS： HTTPS 的 URL 以 "https://" 开头。
4. 证书要求：
   - HTTP： HTTP 不需要服务器端的数字证书。
   - HTTPS： HTTPS 要求服务器端具有有效的 SSL/TLS 数字证书，以便客户端验证服务器的身份。这可以防止中间人攻击。
5. 数据传输方式：
   - HTTP： HTTP 数据传输是明文的，没有加密保护。
   - HTTPS： HTTPS 数据传输经过加密，保护数据的机密性和完整性。
6. 速度：
   - 由于 HTTPS 需要加密和解密数据，因此与 HTTP 相比，它可能会稍微减慢数据传输速度。然而，现代的硬件和协议优化已经减小了这一差距，使 HTTPS 在大多数情况下仍然能够提供良好的性能。

### 24、https的认证是谁认证谁？

HTTPS 的认证是通过数字证书实现的，它涉及到客户端（通常是浏览器）和服务器之间的相互认证。

1. 服务器认证客户端： 服务器会提供其数字证书，其中包含了服务器的公钥，以便客户端验证服务器的身份。这意味着客户端可以确保它正在与正确的服务器通信，而不是中间人（例如，中间人攻击者）。
2. 客户端认证服务器（可选）： 在某些情况下，客户端也可以提供数字证书以进行认证。这在一些特定的应用程序中可能会用到，但在大多数 HTTPS 连接中，客户端认证通常不是必须的。
3. 数据传输加密： 一旦服务器的身份得到验证，客户端和服务器之间的数据传输将通过 SSL/TLS 协议加密，以确保传输的机密性和完整性。这意味着除了服务器和客户端之外的任何人都无法窥视或篡改传输的数据。