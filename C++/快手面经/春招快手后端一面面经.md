# 春招快手后端一面面经

### 1、http1.0和2.0区别？

1. 连接复用
   - HTTP/1.0 每次请求都需要建立和关闭一次 TCP 连接，造成了较大的性能开销。
   - HTTP/2.0 支持连接复用，可以在单个 TCP 连接上同时进行多个请求和响应，减少了连接建立和关闭的开销，提高了性能。
2. 头部压缩
   - HTTP/1.0 的头部信息没有压缩，会占用较多的带宽。
   - HTTP/2.0 使用 HPACK 算法对头部信息进行压缩，减少了传输的数据量，提高了传输效率。
3. 二进制协议
   - HTTP/1.0 使用文本格式传输数据，可读性较好。
   - HTTP/2.0 使用二进制格式传输数据，提高了传输效率，但可读性较差。
4. 流控制
   - HTTP/1.0 没有流控制机制，容易造成数据传输过程中的不稳定性。
   - HTTP/2.0 支持流控制机制，可以根据接收方的处理能力动态调整数据传输速率，提高了传输的稳定性和效率。
5. 服务器推送
   - HTTP/1.0 需要客户端发起请求才能获取资源。
   - HTTP/2.0 支持服务器推送功能，服务器可以在客户端请求之前将相关资源推送给客户端，减少了客户端请求的次数，提高了性能。

### 2、http常见的状态码？

1. 1xx（信息性状态码）：表示请求已被接收，继续处理。
   - 100 Continue：表示服务器已接收到请求的初始部分，客户端应继续请求。
2. 2xx（成功状态码）：表示请求已成功处理。
   - 200 OK：表示请求成功，服务器已成功处理请求。
3. 3xx（重定向状态码）：表示需要进一步操作以完成请求。
   - 301 Moved Permanently：永久重定向，请求的资源已被永久移动到新位置。
   - 302 Found：临时重定向，请求的资源暂时被移动到新位置。
   - 304 Not Modified：资源未修改，客户端可以使用缓存的版本。
4. 4xx（客户端错误状态码）：表示客户端请求有误。
   - 400 Bad Request：请求错误，服务器无法理解请求。
   - 401 Unauthorized：未授权，需要身份验证。
   - 403 Forbidden：禁止访问，服务器拒绝请求。
   - 404 Not Found：未找到资源。
5. 5xx（服务器错误状态码）：表示服务器在处理请求时发生错误。
   - 500 Internal Server Error：服务器内部错误。
   - 502 Bad Gateway：网关错误，服务器作为网关或代理时收到无效响应。
   - 503 Service Unavailable：服务不可用，服务器暂时过载或维护。

### 3、了解多线程么，多线程常见类有哪些，如何创建多线程，为什么要用线程池，线程池的核心参数？

多线程是指在一个进程内同时执行多个线程，每个线程可以独立运行不同的任务。在 C++ 中，常见的多线程类有 `std::thread`、`std::mutex`、`std::condition_variable` 等。

**创建多线程**：

使用 `std::thread` 类可以创建一个新的线程。

```
#include <iostream>
#include <thread>

void threadFunction() {
    std::cout << "Hello from thread!" << std::endl;
}

int main() {
    std::thread t(threadFunction); // 创建新线程并执行 threadFunction 函数
    t.join(); // 等待线程结束
    return 0;
}
```

**线程池的作用和核心参数**：

线程池是一种管理和复用线程的机制，它可以减少线程创建和销毁的开销，并且可以控制并发线程的数量，防止系统过载。

在 C++11 之后，可以使用 `std::thread` 和其他标准库组件来实现线程池，也可以使用第三方库如 Boost 和 PPL。

**线程池的核心参数包括**：

- 线程数量：决定了同时执行的线程数目。
- 任务队列：用于存储待执行的任务，线程从队列中取出任务执行。
- 任务分发策略：确定如何将任务分配给空闲线程。

**为什么要使用线程池？**

1. 降低资源消耗：避免频繁创建和销毁线程的开销。
2. 提高性能：复用线程可以减少线程切换的开销，提高处理任务的效率。
3. 控制并发度：可以限制同时执行的线程数量，防止系统过载。

### 4、MySQL索引结构？

MySQL中的索引是一种数据结构，用于快速查找数据库表中的记录。它类似于书籍的目录，可以帮助数据库引擎快速定位到要查询的数据，而不必扫描整个表。MySQL支持多种类型的索引，包括B-tree索引、哈希索引、全文索引等，其中B-tree索引是最常用的一种。

1. **B-tree索引**（平衡树索引）：B-tree索引是MySQL中最常用的索引类型之一。它可以加速等值查询、范围查询和排序操作。B-tree索引按照一定规则组织数据，使得查询时可以快速定位到目标记录。B-tree索引适用于各种数据类型，包括整数、字符串等。

   B-Tree索引的特点：

   - 平衡性：每个节点的子节点数大致相等，确保了查询效率的稳定性。
   - 多层结构：数据量大时，索引会形成多层结构，但树的高度通常较低，查询效率高。
   - 范围查询：B-Tree索引适用于范围查询，可以快速定位到范围内的数据。

2. **B+树索引**：是一种在数据库索引中常用的数据结构，它是B树的一种变种。与B树不同的是，B+树的非叶子节点只存储键值信息，不存储数据记录的具体内容，所有数据记录都存储在叶子节点中。这种设计使得B+树在范围查询时更加高效，因为所有叶子节点构成了一个有序链表，可以快速地找到一个范围内的数据。

   B+树的特点包括：

   - 节点结构：B+树的节点通常包括一个父节点指针、若干个键值对、若干个子节点指针。叶子节点包含键值对和指向相邻叶子节点的指针。
   - 有序性：所有叶子节点构成了一个有序链表，可以方便地进行范围查询。
   - 平衡性：B+树保持了树的平衡性，即任意两个叶子节点之间的路径长度相同，保证了查询的稳定性和效率。
   - 适用范围：B+树适用于范围查询和精确查询，但不适用于模糊查询。
   - 减少磁盘IO：由于叶子节点存储了所有数据记录，查询时可以减少磁盘IO操作。

3. **哈希索引**：哈希索引是另一种索引类型，适用于等值查询。它将索引键的值通过哈希函数映射到一个哈希表中，从而快速查找到目标记录。哈希索引适用于等值查询，但不适用于范围查询和排序操作。

4. **全文索引**：全文索引允许在文本数据中进行全文搜索。它可以加速对文本字段的搜索操作，例如查找包含特定单词或短语的记录。全文索引需要特殊的配置和支持，不是所有的存储引擎都支持全文索引。

5. **空间索引**：空间索引用于几何数据类型，如Point、LineString、Polygon等。它可以加速空间数据的查询和分析，例如查找某个点是否在多边形内部。

### 5、怎么设计MySQL的表的？

设计MySQL表涉及到多个方面，包括表的结构、数据类型、索引、约束等。

1. 确定表的目的：首先要明确表的用途和功能，包括存储哪些数据以及数据之间的关系。
2. 选择合适的数据类型：根据需要存储的数据类型选择合适的MySQL数据类型，例如INT、VARCHAR、TEXT等。
3. 设计表的字段：根据需求确定表的字段，并考虑字段的约束条件，如主键、唯一键、外键等。
4. 选择合适的存储引擎：MySQL支持多种存储引擎，如InnoDB、MyISAM等，根据需求选择合适的存储引擎。
5. 设计表的索引：根据查询需求设计合适的索引，可以提高查询效率。索引可以是单列索引、组合索引等。
6. 考虑数据完整性：使用约束（如NOT NULL、UNIQUE、PRIMARY KEY、FOREIGN KEY等）来确保数据的完整性和一致性。
7. 规范命名：表名、字段名等应该使用有意义的命名，遵循一定的命名规范，便于理解和维护。
8. 考虑性能：设计表结构时要考虑查询的性能，避免设计过多或过少的字段，避免频繁的表连接等操作。
9. 优化表结构：根据实际使用情况对表结构进行优化，包括拆分表、合并表、去除冗余字段等。
10. 备份和恢复：设计表时要考虑数据的备份和恢复策略，确保数据的安全性和可靠性。

### 6、sql优化方式？

1. 使用合适的索引：通过在查询中使用索引，可以大幅提高查询性能。确保在经常用于检索的列上创建索引，并避免在不必要的列上创建索引。
2. 优化查询语句：编写高效的查询语句是SQL优化的核心。避免使用SELECT *，只选择需要的列；使用JOIN时，确保连接条件合适；避免在WHERE子句中使用不必要的函数。
3. 避免全表扫描：尽量避免在大表上进行全表扫描，可以通过添加索引或使用更精确的条件来避免。
4. 合理使用事务：事务会增加数据库的负载，因此应该尽量缩短事务的执行时间，并在必要时使用事务隔离级别。
5. 避免过度连接：过度连接多个表会增加数据库的负载，可以考虑使用子查询或临时表来减少连接。
6. 分批处理数据：对大批量数据的操作应该分批进行，避免一次性操作大量数据导致数据库性能下降。
7. 定期优化表结构：定期分析和优化表结构，包括添加或删除索引、拆分或合并表等操作。
8. 使用EXPLAIN分析查询计划：使用EXPLAIN语句分析查询计划，找出潜在的性能问题，并根据需要调整查询语句或索引。
9. 避免使用动态SQL：动态SQL会增加数据库的负载和风险，应尽量避免使用动态SQL拼接。
10. 合理使用缓存：使用数据库缓存（如MySQL的查询缓存）或应用程序缓存来减少数据库的访问次数。

### 7、Redis用过么? 程序中哪些地方用到redis？

开源的内存数据库，可以用作缓存、消息代理和实时分析等多种用途。

1. 缓存：最常见的用途是作为缓存存储，用来加速对数据库或其他IO密集型操作的访问。通过将经常访问的数据存储在Redis中，可以避免重复计算或IO操作，提高系统的响应速度和性能。
2. 会话存储：可以将用户的会话数据存储在Redis中，以提高会话管理的效率和性能。这样可以避免在每个请求中都访问数据库或文件系统来获取会话信息。
3. 消息队列：Redis的发布/订阅功能可以用作简单的消息队列，用于在应用程序之间传递消息或事件。
4. 计数器和排行榜：可以使用Redis的原子操作来实现计数器和排行榜功能，如统计网站的访问量、点赞数等。
5. 分布式锁：Redis可以用作分布式锁的实现，在分布式系统中确保同一时刻只有一个客户端能够访问共享资源。
6. 实时数据分析：Redis支持对数据进行快速的读写操作，可以用于实时数据分析、日志处理等场景。

### 8、Redis基础数据结构？

1. String（字符串）：
   - 存储一个字符串值。
   - 可以设置过期时间。
   - 可以对字符串进行操作，如追加、获取子串等。
2. List（列表）：
   - 一个有序的字符串列表。
   - 可以在列表的两端进行元素的插入和删除操作，支持类似栈和队列的操作。
   - 可以用作消息队列的实现。
3. Set（集合）：
   - 一个不重复且无序的集合。
   - 支持对集合进行交集、并集、差集等操作。
   - 适合存储唯一值的场景，如用户的标签、点赞的用户等。
4. Sorted Set（有序集合）：
   - 一个有序的、不重复的集合。
   - 每个成员都关联一个分数（score），根据分数对成员进行排序。
   - 可以用来存储排行榜、优先级队列等数据。
5. Hash（哈希表）：
   - 一个键值对的无序集合。
   - 可以存储多个字段和值，类似于关联数组。
   - 适合存储对象或结构化数据。
6. Bitmaps（位图）：
   - 可以对位进行操作的数据结构。
   - 可以用来进行高效的标记和统计操作，如用户签到、活跃用户统计等。
7. HyperLogLog（基数统计）：
   - 用于估计一个集合中不重复元素的数量。
   - 可以用来进行基数统计，如统计网站的UV（独立访客）数等。

### 9、延迟双删？

延迟双删（Delayed Double Delete）是一种解决并发环境下删除操作可能引发的问题的技术。在并发环境下，当多个线程或进程同时对数据进行操作时，可能会出现删除冲突的情况。延迟双删通过引入延迟删除和双重删除的机制来解决这个问题。

延迟双删的基本思想是在进行删除操作时，不立即删除数据，而是将数据标记为“已删除”，并在一定的延迟时间后再真正删除数据。这样可以给其他操作足够的时间来处理已删除数据的相关操作，从而避免删除冲突。

延迟双删的实现可以分为以下几个步骤：

1. 标记为“已删除”：在进行删除操作时，不直接删除数据，而是将数据标记为“已删除”，可以通过在数据中添加一个标记字段或修改状态字段的方式来实现。
2. 延迟删除：在标记数据为“已删除”后，不立即删除数据，而是等待一定的延迟时间。这个延迟时间可以根据实际情况来调整，通常需要考虑到系统的并发量和数据处理时间等因素。
3. 双重删除：在延迟时间到达后，再次检查数据的状态。如果数据仍然处于“已删除”状态，则执行真正的删除操作。如果数据已经被其他操作修改，则放弃删除操作。

### 10、算法题：中等算法题（挂）