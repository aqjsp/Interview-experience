# 小米澎湃OS - C++开发二面

> 来源：https://www.nowcoder.com/discuss/610414092750237696

### 1、linux常用命令举例？

这里小伙伴也给了建议不要举什么cd的，可以说稍微有技术含量的，比如tail 用来查日志，cat 用来查看小文件，ps 用来查看进程，pwd 查看当前目录，grep用来过滤，top 用来查看 cpu 的使用率，chomd 用来修改权限，ash 用来远程登陆。



### 2、进程，线程区别？

1. 定义：
   - 进程：是程序的一次执行过程，是操作系统进行资源分配和调度的一个独立单位。
   - 线程：是进程的一个执行单元，是操作系统进行调度的最小单位，它可以与同属一个进程的其他线程共享进程所拥有的全部资源。
2. 资源拥有：
   - 进程：拥有独立的地址空间、文件描述符、堆栈和数据段等资源。
   - 线程：共享所属进程的地址空间和其他资源，如文件描述符、堆栈、数据段等。
3. 通信和同步：
   - 进程：进程间通信（IPC）比较复杂，需要借助于操作系统提供的机制，如管道、信号量、消息队列等。
   - 线程：线程间通信（IPC）较为简单，可以直接通过共享内存等方式进行通信。
4. 创建和销毁开销：
   - 进程：创建和销毁较为复杂，需要分配和回收大量资源。
   - 线程：创建和销毁较为简单，开销较小。
5. 并发性：
   - 进程：进程之间相互独立，因此可以并发执行。
   - 线程：同一进程内的多个线程共享进程的资源，可以实现并发执行。

### 3、进程间通信方式？

1. 管道：
   - 单向通信，分为匿名管道和命名管道。
   - 匿名管道只能用于具有亲缘关系的进程间通信，一般在创建子进程时使用。
   - 命名管道可以用于无亲缘关系的进程间通信，通过文件系统中的特殊文件实现。
2. 信号：
   - 用于通知进程发生了某种事件。
   - 可以用于进程间的简单通信，但只能传递少量信息。
3. 消息队列：
   - 允许一个进程向另一个进程发送消息的队列。
   - 消息队列独立于发送和接收进程，可以提供异步通信的能力。
4. 共享内存：
   - 允许多个进程共享同一段内存空间。
   - 由于是直接访问内存，所以速度快，但需要考虑同步和互斥问题。
5. 信号量：
   - 用于进程间同步和互斥的一种机制。
   - 可以用来解决进程对共享资源的争用问题，保证多个进程之间的同步。
6. 套接字：
   - 在网络编程中用于不同主机间的进程通信，也可以用于同一主机内的进程间通信。
   - 提供了一种统一的通信接口，可以实现进程间的数据交换。
7. 文件锁：
   - 使用文件系统的锁机制来实现进程间的同步。
   - 可以通过对文件进行加锁和解锁来控制进程对文件的访问。

### 4、源文件到可执行文件的过程？

1. 预处理：
   - 预处理器（如C预处理器）会处理源文件，执行诸如包含头文件、宏展开、条件编译等操作，生成经过预处理的中间文件。
2. 编译：
   - 编译器（如GCC、Clang等）将预处理后的文件转换为汇编代码（Assembly Code），汇编代码是一种低级的表示，使用特定的汇编语言描述源代码的操作和数据。
3. 汇编：
   - 汇编器（Assembler）将汇编代码转换为机器码（Machine Code），即二进制指令，这些指令可以被计算机硬件直接执行。
4. 链接：
   - 链接器（Linker）将编译后的目标文件与所需的库文件链接在一起，生成最终的可执行文件。
   - 链接器会解析符号引用（Symbol References），将源文件中引用的函数或变量与其定义所在的位置进行关联，最终生成一个完整的可执行文件。
5. 装载（可选）：
   - 如果生成的可执行文件需要在运行时动态加载库文件，操作系统的加载器会负责将这些库文件加载到内存中。
6. 运行：
   - 最终生成的可执行文件被操作系统加载到内存中，并由CPU执行，实现了源文件的功能。

### 5、linux内存空间分布（这个应该是要区分一下c++内存分布？）

1. 内核空间（Kernel Space）：
   - 内核空间是操作系统内核运行的内存区域，通常位于高地址部分。
   - 内核空间包含了操作系统内核的代码和数据结构，用于管理系统资源和提供系统调用服务。
2. 用户空间（User Space）：
   - 用户空间是用户程序运行的内存区域，通常位于低地址部分。
   - 用户空间包含了用户程序的代码和数据，以及用户空间的堆、栈等区域。
3. 堆（Heap）：
   - 堆是由malloc、free等函数动态分配和释放的内存区域，位于用户空间。
   - 堆的大小可以动态增长或缩小，受限于操作系统和编译器的限制。
4. 栈（Stack）：
   - 栈是用于函数调用和局部变量存储的内存区域，位于用户空间。
   - 每个线程都有自己的栈，栈的大小通常固定或受限于操作系统和编译器的限制。
5. 共享库空间（Shared Libraries Space）：
   - 共享库空间包含了系统和用户共享的动态链接库（shared libraries）。
   - 这些库在内存中只需加载一次，不同的程序可以共享这些库的代码和数据。
6. 内存映射区域（Memory-mapped Region）：
   - 内存映射区域用于将文件映射到内存，以便直接读写文件而不需要通过系统调用。
   - 这些区域通常用于共享内存、共享库和动态链接等。
7. 内核空间映射（Kernel Space Mapping）：
   - 内核空间映射用于将内核空间的部分内容映射到用户空间，以便用户程序访问内核数据结构和执行系统调用。

### 6、堆和栈的区别？

1. 分配方式：
   - 栈（Stack）：栈是一种连续的内存区域，由系统自动分配和释放。栈上的内存分配和释放遵循"先进后出"（LIFO）的原则。
   - 堆（Heap）：堆是一种动态分配的内存区域，程序员可以根据需要手动申请和释放内存。堆上的内存分配和释放顺序没有特定规律。
2. 空间大小：
   - 栈：栈的空间通常较小，通常由操作系统预先分配一定大小的栈空间给每个线程使用，超出大小会导致栈溢出。
   - 堆：堆的空间通常较大，可以动态增长或缩小，受限于操作系统和编译器的限制。
3. 分配效率：
   - 栈：栈上的内存分配和释放速度较快，只需移动栈指针即可。
   - 堆：堆上的内存分配和释放速度较慢，需要进行内存管理和碎片整理。
4. 生命周期：
   - 栈：栈上的变量生命周期由其所在的函数决定，函数返回时变量会被自动释放。
   - 堆：堆上的变量生命周期可以由程序员控制，需要手动释放内存，否则可能会导致内存泄漏。
5. 使用方式：
   - 栈：栈通常用于存储局部变量、函数参数和函数返回地址等，适合存储生命周期短暂的数据。
   - 堆：堆通常用于存储动态分配的对象和数据结构，适合存储生命周期较长的数据。

### 7、开发过程中遇到过内存泄漏的问题，怎么解决的，或者怎么定义内存泄漏？

内存泄漏指的是程序在动态分配内存后，未能及时释放该内存造成的现象。在开发过程中，内存泄漏可能会导致程序占用的内存越来越多，最终耗尽系统的可用内存，导致程序崩溃或系统变慢。

内存泄漏的解决方法：

1. 检测内存泄漏：使用内存泄漏检测工具（如Valgrind、Dr.Memory等）来检测程序中的内存泄漏问题。这些工具可以帮助定位内存泄漏的位置和原因。
2. 分析内存泄漏原因：通过检测工具的报告，分析内存泄漏的原因。可能的原因包括未释放动态分配的内存、循环引用导致的内存泄漏等。
3. 修复内存泄漏：根据分析结果，修复内存泄漏问题。主要包括以下几个方面：
   - 在合适的位置释放动态分配的内存，确保每次分配内存都有对应的释放操作。
   - 避免循环引用，可以使用智能指针等工具来管理对象的生命周期，避免手动管理内存带来的问题。
   - 使用容器类（如std::vector、std::list等）来管理数据，避免手动管理内存造成的错误。
4. 测试和验证：修复内存泄漏后，进行测试和验证，确保内存泄漏问题已经解决。

### 8、有没有用过内存泄漏检查工具？

Valgrind是一个强大的开源工具，用于检测内存泄漏、内存错误和线程错误等问题。它可以检测C、C++等语言编写的程序，并提供详细的报告来帮助定位和解决问题。

使用Valgrind进行内存泄漏检查的一般步骤如下：

1. 编译程序：使用Valgrind提供的工具来编译你的程序，例如使用`valgrind --tool=memcheck`命令。
2. 运行程序：使用Valgrind运行你的程序，例如`valgrind ./your_program`。Valgrind会监控程序的内存使用情况。
3. 分析报告：Valgrind会生成详细的报告，包括内存泄漏的位置、大小和相关调用堆栈信息。根据报告定位并修复内存泄漏问题。

### 9、进程同步的方式，信号量和互斥锁的区别？

1. 信号量：
   - 信号量是一种计数器，用于控制多个进程对共享资源的访问。
   - 信号量可以有两种类型：二进制信号量和计数信号量。二进制信号量的取值只能为0或1，用于互斥访问共享资源；计数信号量的取值可以大于1，用于限制资源的数量。
   - 使用信号量时，进程可以通过 `wait` 操作来等待资源变为可用，通过 `signal` 操作来释放资源。
   - 信号量可以用于解决生产者-消费者问题、读者-写者问题等。
2. 互斥锁：
   - 互斥锁是一种特殊的信号量，只能取值0或1，用于实现对共享资源的互斥访问。
   - 使用互斥锁时，进程可以通过 `lock` 操作来获取锁，如果锁已被其他进程获取，则进入等待状态；通过 `unlock` 操作来释放锁。
   - 互斥锁通常用于保护临界区，确保在同一时刻只有一个进程可以访问临界区。
3. 区别：
   - 信号量可以用于控制资源的数量，而互斥锁只能用于实现互斥访问。
   - 信号量可以用于进程间通信，而互斥锁通常用于线程间同步。
   - 互斥锁的实现通常比信号量更轻量级，性能更高。

### 10、信号和信号量的区别？

1. 概念：
   - 信号（Signal）是一种异步通信机制，用于通知进程发生了特定事件，如硬件异常、软件事件等。信号可以在任何时候发送给进程，而进程需要安装信号处理器来处理信号。
   - 信号量（Semaphore）是一种同步机制，用于控制对共享资源的访问。信号量是一个计数器，用于表示可用资源的数量，进程可以通过对信号量执行操作来申请或释放资源。
2. 用途：
   - 信号常用于处理异步事件，如按下键盘、接收到网络数据等，以及进程间的通知。
   - 信号量常用于实现进程间的同步和互斥，控制对共享资源的访问。
3. 操作：
   - 信号由操作系统或进程发送，接收信号的进程需要安装信号处理器来处理信号。
   - 信号量是由进程通过系统调用（如 `sem_wait`、`sem_post`）来操作的，用于控制对共享资源的访问。
4. 特性：
   - 信号是一次性的，即一旦发送并被接收处理，就不再有效。
   - 信号量是持久的，即其值在操作之间保持不变，直到被显式地改变。
5. 示例：
   - 信号的例子包括 `SIGINT` 用于终止进程、`SIGSEGV` 用于处理段错误等。
   - 信号量的例子包括用于控制共享内存访问的信号量、用于控制进程数量的信号量等。

### 11、函数指针和指针函数的区别？

1. 函数指针（Function Pointer）：
   - 函数指针是指向函数的指针变量，可以用来间接调用函数。
   - 函数指针的声明形式为 `返回类型 (*指针变量名)(参数列表)`，例如 `int (*funcPtr)(int, int)` 表示一个返回类型为 `int`、接受两个 `int` 参数的函数指针。
   - 函数指针通常用于实现回调函数、动态选择函数等场景，通过在运行时指定函数指针来调用不同的函数。
2. 指针函数（Pointer to Function）：
   - 指针函数是一个返回指针的函数，即函数的返回类型为指针类型。
   - 指针函数的声明形式为 `返回类型 (*函数名)(参数列表)`，例如 `int *(*func)(int, int)` 表示一个返回类型为 `int*`、接受两个 `int` 参数的指针函数。
   - 指针函数通常用于返回动态分配的内存地址或者函数指针。

```
#include <iostream>
using namespace std;

// 函数指针示例：定义一个函数指针类型
typedef int (*FuncPtr)(int, int);

// 指针函数示例：返回一个指向整数的指针的函数
int* getIntegerPtr(int x) {
    int* ptr = new int;
    *ptr = x;
    return ptr;
}

// 函数指针示例：加法函数
int add(int a, int b) {
    return a + b;
}

int main() {
    // 函数指针示例：定义并初始化一个函数指针
    FuncPtr ptr = add;
    cout << "Function pointer result: " << ptr(1, 2) << endl;

    // 指针函数示例：调用指针函数并使用返回值
    int* intPtr = getIntegerPtr(42);
    cout << "Pointer function result: " << *intPtr << endl;
    delete intPtr;

    return 0;
}
```

### 12、TCP三次握手和四次挥手？

#### 三次握手





### 13、为什么要四次断开，不是三次或者两次？

### 14、select poll  ，epoll的区别？

### 15、大端字节和小端字节的区别？

### 16、手撕，判断回文数