# 腾讯云智一面面经，洒洒水喽~

> 来源：https://www.nowcoder.com/discuss/620573809690591232

### 1、说一下堆区和栈区，为什么要划分出这两个区？

#### 堆区（Heap）

**特点：**

1. 动态内存分配：堆区用于动态分配内存，程序在运行时可以使用`malloc`、`calloc`、`realloc`（在C语言中）或`new`（在C++中）等函数从堆区申请内存。
2. 手动管理：程序员必须手动管理堆内存的分配和释放。例如，在C语言中，需要使用`free`函数来释放内存；在C++中，则使用`delete`。
3. 内存大小：堆区的内存大小较大，但由于需要手动管理，容易导致内存泄漏（忘记释放已分配的内存）和内存碎片（频繁分配和释放内存后，空闲内存不连续）。
4. 访问速度较慢：堆内存的访问速度比栈内存慢，因为堆区需要维护复杂的数据结构以跟踪已分配和未分配的内存块。

#### 栈区（Stack）

**特点：**

1. 自动内存分配：栈区用于存储函数调用时的局部变量和函数参数。内存的分配和释放由编译器自动管理。
2. LIFO（后进先出）结构：栈是一种后进先出的数据结构，遵循“最后分配的内存最先释放”的原则。函数调用时，局部变量在栈上分配；函数返回时，这些变量自动释放。
3. 内存大小有限：栈的大小通常比堆小，但足以满足大多数函数调用的需求。栈内存的大小通常由操作系统和编译器设定。
4. 访问速度快：栈内存的访问速度比堆快，因为栈的结构简单，并且局部变量通常存储在CPU的高速缓存中。

#### 划分堆区和栈区的原因

1. 内存管理的灵活性：堆区允许动态内存分配，使程序可以根据需要动态调整内存使用。这对于处理不确定大小的数据结构（如链表、树等）非常重要。
2. 内存管理的效率：栈区提供了快速的内存分配和释放机制，适用于生命周期较短的局部变量和函数调用。栈区内存的分配和释放由编译器自动处理，减少了程序员的负担。
3. 内存使用的安全性：栈区由于自动管理内存，可以减少内存泄漏的风险。而堆区虽然灵活，但需要程序员小心管理，以避免内存泄漏和碎片问题。
4. 资源的合理分配：操作系统可以根据不同的需求和程序的特点，将内存资源合理划分给堆区和栈区，以提高系统的整体性能和稳定性。

### 2、函数是如何调用的？

#### 1. 函数调用前准备

当一个函数被调用时，首先需要进行一些准备工作：

**传递参数：**

- 调用者（caller）需要将函数参数传递给被调用函数（callee）。这通常通过栈或寄存器完成，具体方式取决于调用约定（calling convention）。
- 在多数调用约定中，参数从右到左推入栈中，或者通过寄存器传递。

**保存状态：**

- 调用者可能需要保存当前的CPU寄存器状态，以便在函数返回后能恢复执行状态。

#### 2. 函数调用过程

**压栈：**

- 将参数压入栈中（如果采用栈传递参数）。
- 将返回地址压入栈中，这个地址是函数执行完毕后程序需要返回的位置。

**跳转到函数：**

- 执行跳转指令（如x86架构中的`CALL`指令）跳转到函数的入口地址。

#### 3. 函数执行

进入函数后，需要执行一些初始设置：

**设置栈帧（Stack Frame）：**

- 为了管理局部变量和参数，函数通常会设置一个新的栈帧。栈帧由帧指针（Frame Pointer，FP，也称作基址指针，BP）和栈指针（Stack Pointer，SP）管理。
- 保存调用者的帧指针，更新当前的帧指针到栈顶位置。
- 为局部变量预留空间，更新栈指针。

**执行函数体：**

- 函数执行其内部代码，包括对局部变量的操作、调用其他函数等。

#### 4. 函数返回

当函数执行完毕，需要返回调用者，并可能返回一个值：

**清理栈帧：**

- 恢复原来的帧指针，释放局部变量占用的栈空间。
- 如果使用栈传递参数，需要清理参数。

**返回值：**

- 如果函数有返回值，通常通过寄存器传递，例如x86架构中使用EAX寄存器。

**跳转回调用点：**

- 从栈中弹出返回地址，并跳转到该地址继续执行调用者的代码。

#### 具体示例

以x86架构为例，假设我们有如下函数：

```
int add(int a, int b) {
    return a + b;
}
```

调用`add(2, 3)`时，典型的汇编指令流程如下：

1. **压栈参数**：

   ```
   push 3          ; 将参数b压入栈
   push 2          ; 将参数a压入栈
   ```

2. **调用函数**：

   ```
   call add        ; 调用add函数，压入返回地址并跳转到add函数入口
   ```

3. **设置栈帧**（在add函数内部）：

   ```
   add:
   push ebp        ; 保存调用者的帧指针
   mov ebp, esp    ; 设置当前函数的帧指针
   sub esp, 4      ; 为局部变量预留空间（假设需要4字节）
   ```

4. **执行函数体**：

   ```
   mov eax, [ebp+8] ; 取参数a
   mov ecx, [ebp+12] ; 取参数b
   add eax, ecx     ; 计算a + b
   ```

5. **清理栈帧并返回**：

   ```
   mov esp, ebp    ; 恢复栈指针
   pop ebp         ; 恢复调用者的帧指针
   ret             ; 从栈中弹出返回地址并跳转
   ```

#### 调用约定（Calling Conventions）

不同的调用约定对函数调用的具体细节有不同的规定。常见的调用约定包括：

- CDECL：参数从右到左压栈，调用者清理栈。
- STDCALL：参数从右到左压栈，被调用者清理栈。
- FASTCALL：部分参数通过寄存器传递，剩余参数从右到左压栈。
- THISCALL：用于C++成员函数调用，`this`指针通过寄存器传递，其余参数根据具体约定。

### 3、介绍一下指针和引用，它们在作为参数类型时，如何传递参数？

#### 指针

**定义和特点：**

- 指针是一个变量，用于存储另一个变量的内存地址。
- 使用`*`运算符来定义指针，使用`&`运算符来获取变量的地址。

**声明和使用：**

```
int a = 10;
int *p = &a;  // p是指向a的指针
```

**访问指针指向的值：**

```
int value = *p;  // 通过解引用访问指针p指向的值
```

#### 引用

**定义和特点：**

- 引用是一个别名，它是对另一个变量的引用。
- 使用`&`运算符来定义引用，引用一旦绑定到一个变量，就不能再绑定到其他变量。

**声明和使用：**

```
int a = 10;
int &ref = a;  // ref是a的引用
```

**访问引用指向的值：**

```
int value = ref;  // 直接使用ref就可以访问a的值
```

#### 指针和引用作为参数类型

##### 指针作为参数

当指针作为函数参数时，函数接收的是参数变量的地址，可以直接修改参数变量的值。

**函数定义和调用：**

```
void increment(int *p) {
    (*p)++;  // 解引用指针并修改值
}

int main() {
    int a = 10;
    increment(&a);  // 传递a的地址
    // a的值变为11
    return 0;
}
```

##### 引用作为参数

当引用作为函数参数时，函数接收的是参数变量的引用，可以直接修改参数变量的值。引用参数在函数调用时更加直观，因为不需要显式传递地址。

**函数定义和调用：**

```
void increment(int &ref) {
    ref++;  // 直接修改引用的值
}

int main() {
    int a = 10;
    increment(a);  // 直接传递a
    // a的值变为11
    return 0;
}
```

#### 对比指针和引用

- **语法简洁**：引用语法更加简洁、直观，不需要使用解引用运算符`*`。
- **不可为空**：引用必须绑定到有效的变量，不能为NULL。指针可以为空（NULL），需要检查是否为空以避免空指针访问错误。
- **不可重绑定**：引用在初始化后不能绑定到另一个变量。指针可以在任何时候指向不同的变量。
- **更安全**：引用更安全，减少了指针操作中的潜在错误（如空指针、悬空指针）。

### 4、说一下常用的索引？

#### B树索引

**特点：**

- B树（B-tree）或其变体B+树（B+tree）是最常见的索引类型。
- 适用于范围查询、大量数据的排序操作。
- 平衡树结构，所有叶子节点在同一层。
- 支持等值查询和范围查询，如`=`, `<`, `>`, `BETWEEN`, `LIKE 'abc%'`。

**优点：**

- 维护数据的有序性。
- 查询效率高，尤其是范围查询。
- 插入、删除操作性能较好。

**缺点：**

- 占用一定的存储空间。
- 在频繁的写操作下，维护树结构的代价较高。

**使用场景：**

- 主键、唯一键等经常用于排序和搜索的字段。
- 需要支持范围查询的字段。

#### 2. 哈希索引

**特点：**

- 使用哈希表实现，键值通过哈希函数计算位置。
- 仅支持等值查询，如`=`、`IN`。
- 查询速度非常快，但不支持范围查询。

**优点：**

- 等值查询效率极高。
- 插入和删除操作性能优秀。

**缺点：**

- 不支持范围查询。
- 哈希冲突可能导致性能下降。
- 无法维护数据的有序性。

**使用场景：**

- 频繁进行等值查询的字段。
- 不需要进行范围查询的场景。

#### 3. 位图索引

**特点：**

- 使用位图（bitmaps）来表示字段的值。
- 每个不同值对应一个位图，每个位表示该值是否在对应的记录中出现。
- 非常适合低基数（low cardinality）的字段，即字段值种类较少。

**优点：**

- 在低基数、高查询密度的场景下，查询效率高。
- 存储空间利用率高。

**缺点：**

- 更新操作成本高，尤其是在高并发写入的环境下。
- 适用于静态或变化较少的数据。

**使用场景：**

- 数据仓库中，用于分析和统计的字段。
- 低基数字段，如性别、状态等。

#### 4. 全文索引

**特点：**

- 用于对大文本字段进行全文搜索。
- 支持自然语言查询和布尔查询。
- 创建反向索引，将文档中的词映射到文档ID。

**优点：**

- 可以高效地进行复杂文本搜索。
- 支持多种匹配模式（如前缀匹配、布尔匹配等）。

**缺点：**

- 占用较多存储空间。
- 创建和维护索引的开销较大。

**使用场景：**

- 博客、新闻网站等需要全文搜索的场景。
- 大量文本数据的检索和分析。

#### 5. 空间索引

**特点：**

- 用于存储和查询地理空间数据。
- 常见的数据结构包括R树（R-tree）和四叉树（Quadtree）。
- 支持地理范围查询和空间关系查询（如邻近、包含等）。

**优点：**

- 能够有效处理地理空间数据的查询。
- 提供了快速的空间查询能力。

**缺点：**

- 复杂的索引结构，维护成本较高。
- 需要特定的数据库系统支持（如PostGIS, Oracle Spatial等）。

**使用场景：**

- 地理信息系统（GIS），如地图应用、位置服务等。
- 需要进行空间数据查询的应用。

#### 6. 聚簇索引

**特点：**

- 数据表中的记录按索引顺序存储。
- 一个表只能有一个聚簇索引，通常为主键。
- 数据行实际存储顺序和索引顺序一致。

**优点：**

- 读取范围查询速度快，因为数据物理上连续存储。
- 减少了I/O操作，查询效率高。

**缺点：**

- 插入、删除、更新操作的性能可能较低，因需要维护数据顺序。
- 索引创建和维护的开销较大。

**使用场景：**

- 需要频繁进行范围查询的表。
- 主键或具有唯一约束的列。

#### 7. 非聚簇索引

**特点：**

- 索引结构独立于数据存储，索引中存储键值和指向实际数据行的指针。
- 一个表可以有多个非聚簇索引。

**优点：**

- 允许对不同的列进行多个索引。
- 提供了灵活的查询优化选择。

**缺点：**

- 查询速度比聚簇索引慢，因为需要额外的I/O操作。
- 插入、删除和更新操作的开销较大。

**使用场景：**

- 经常用于查找单一值或少量记录的列。
- 需要对多个列进行索引的场景。

### 5、MySQL引擎有哪些，说一下 InnoDB 和 MyISAM 的区别？

#### InnoDB 和 MyISAM 的区别

##### 1. 事务支持

**InnoDB:**

- 支持事务（ACID 属性），即原子性、一致性、隔离性、持久性。
- 提供支持事务的标准语句，如 `BEGIN`, `COMMIT`, `ROLLBACK`。
- 支持自动恢复机制，确保在系统崩溃后数据的一致性。

**MyISAM:**

- 不支持事务。
- 每个查询独立执行，不能回滚或提交。

##### 2. 外键支持

**InnoDB:**

- 支持外键约束，能确保数据的完整性和一致性。
- 外键约束可以自动级联更新和删除（CASCADE）。

**MyISAM:**

- 不支持外键约束，数据完整性需要在应用层手动维护。

##### 3. 锁机制

**InnoDB:**

- 支持行级锁（Row-level locking），即每次锁定的是表中的一行。
- 行级锁提高了并发性能，特别是高并发读写场景。

**MyISAM:**

- 支持表级锁（Table-level locking），即每次锁定整个表。
- 适合以读操作为主的应用，因为写操作会锁住整个表，阻塞其他读写操作。

##### 4. 数据存储和索引

**InnoDB:**

- 将数据和索引存储在一个共享表空间（tablespace）或每个表独立的.ibd文件中。
- 支持聚簇索引（Clustered Index），主键索引和数据存储在一起，提高了主键查询的性能。

**MyISAM:**

- 将数据存储在.MYD文件中，索引存储在.MYI文件中。
- 使用非聚簇索引，数据和索引分开存储。

##### 5. 性能和使用场景

**InnoDB:**

- 适合需要高并发读写、事务处理、数据完整性要求高的应用场景。
- 常用于OLTP（在线事务处理）系统。

**MyISAM:**

- 适合读操作频繁、对事务要求不高的应用场景。
- 常用于OLAP（在线分析处理）系统、数据仓库、数据归档等。

##### 6. 数据恢复和崩溃安全

**InnoDB:**

- 支持崩溃恢复，通过日志文件（redo log）和检查点（checkpoint）机制恢复未完成的事务，保证数据一致性。
- 自动检查并修复数据文件中的损坏记录。

**MyISAM:**

- 不支持崩溃恢复，数据文件损坏时需要手动修复。
- 提供`myisamchk`工具用于检查和修复表。

##### 7. 全文索引

**InnoDB:**

- 从MySQL 5.6版本开始支持全文索引，但性能不如MyISAM。

**MyISAM:**

- 原生支持全文索引，适合大文本字段的搜索操作。

### 6、说一下事务？

事务是一组操作的集合，这些操作要么全部成功，要么全部失败。事务的主要目的是保证数据库的一致性和完整性。事务通常具有以下四个特性，称为ACID特性：

1. **原子性（Atomicity）**：事务中的所有操作要么全部完成，要么完全不执行。如果事务中的任何一个操作失败，整个事务会回滚到事务开始时的状态，就像这个事务从未执行过一样。
2. **一致性（Consistency）**：事务在完成时，必须使数据库从一个一致性状态变到另一个一致性状态。换句话说，事务的执行不能破坏数据库的完整性约束。
3. **隔离性（Isolation）**：在事务并发执行时，一个事务的执行不应该影响到其他事务的执行。不同的隔离级别决定了一个事务在多大程度上受到其他事务的影响。
4. **持久性（Durability）**：一旦事务提交，其对数据库的改变是永久的，即使系统崩溃，事务的结果也不会丢失。

#### 事务的生命周期

1. 开始事务：事务开始时，所有操作都会被记录在事务日志中。
2. 执行操作：事务执行一系列的数据库读写操作。
3. 提交事务：如果所有操作成功完成，则提交事务，所有更改持久化到数据库。
4. 回滚事务：如果任何操作失败，则回滚事务，撤销所有已执行的操作，恢复到事务开始时的状态。

### 7、说一下 MVCC 机制？

多版本并发控制（MVCC）是一种用于实现数据库并发控制的机制，特别是为了提高数据库在高并发环境下的性能和一致性。MVCC 通过维护数据的多个版本，使读操作和写操作可以并发执行，从而减少锁竞争，提高系统的并发性能。

**使用场景**

MVCC 适用于读多写少的场景，如在线事务处理系统（OLTP），这类系统通常具有高并发读写需求。通过 MVCC，可以在保证数据一致性的同时，提高系统的整体性能和响应速度。

### 8、隔离级别有哪些？MVCC 机制用于哪些隔离级别？

#### 四种隔离级别

1. **读未提交（Read Uncommitted）**
   - 特性：允许事务读取其他未提交事务的变更。
   - 优点：并发性最高。
   - 缺点：可能导致脏读（Dirty Read）、不可重复读（Non-Repeatable Read）和幻读（Phantom Read）。
   - 使用场景：几乎不使用，因为数据一致性风险较高。
2. **读已提交（Read Committed）**
   - 特性：只允许事务读取其他已提交事务的变更。
   - 优点：避免了脏读。
   - 缺点：可能导致不可重复读和幻读。
   - 使用场景：多数数据库系统的默认隔离级别，如 Oracle。
3. **可重复读（Repeatable Read）**
   - 特性：确保在同一事务中多次读取同一数据的结果是一致的。
   - 优点：避免了脏读和不可重复读。
   - 缺点：可能导致幻读。
   - 使用场景：MySQL InnoDB 的默认隔离级别。
4. **序列化（Serializable）**
   - 特性：强制事务顺序执行，确保完全隔离。
   - 优点：避免了脏读、不可重复读和幻读。
   - 缺点：并发性最低，性能开销大。
   - 使用场景：适用于对并发要求非常严格的场景。

#### MVCC 与隔离级别的关系

多版本并发控制（MVCC）主要用于实现以下两种隔离级别：

1. **读已提交（Read Committed）**
2. **可重复读（Repeatable Read）**

在这两个隔离级别中，MVCC 通过维护数据的多个版本，使读操作和写操作可以并发执行，从而减少锁竞争，提高系统的并发性能。

#### MVCC 在不同隔离级别中的实现

1. **读已提交（Read Committed）**
   - 每次读取数据时，事务会获取一个最新的快照，只能看到其他事务已经提交的变更。
   - 不同读操作可能看到不同的版本，容易导致不可重复读。
2. **可重复读（Repeatable Read）**
   - 事务在开始时创建一致性视图，所有读取操作基于这个视图。
   - 在整个事务期间，读取结果一致，避免了不可重复读。
   - 使用 MVCC 维护的数据版本，确保读操作不会阻塞写操作，写操作也不会阻塞读操作。

#### 实现细节

#### 1. 读已提交（Read Committed）

- **Read View**：每次读取数据时，创建一个新的 Read View，确保只能读取已提交的变更。
- **可见性判断**：根据当前活跃事务的快照判断数据版本的可见性。

##### 2. 可重复读（Repeatable Read）

- **Read View**：在事务开始时创建一次 Read View，在整个事务期间保持不变。
- **可见性判断**：事务读取的数据版本基于事务开始时的快照，保证一致性。

#### 事务隔离级别对比

| 隔离级别 | 脏读（Dirty Read） | 不可重复读（Non-Repeatable Read） | 幻读（Phantom Read） | 实现复杂度 | 性能开销 |
| -------- | ------------------ | --------------------------------- | -------------------- | ---------- | -------- |
| 读未提交 | 可能               | 可能                              | 可能                 | 最简单     | 最低     |
| 读已提交 | 不可能             | 可能                              | 可能                 | 较简单     | 较低     |
| 可重复读 | 不可能             | 不可能                            | 可能                 | 中等       | 中等     |
| 序列化   | 不可能             | 不可能                            | 不可能               | 最复杂     | 最高     |

### 9、说一下 MVCC 的实现原理

#### MVCC 的基本原理

MVCC 主要通过以下几种方式来管理数据的多个版本：

1. **数据版本化**：每个数据行不仅存储当前版本，还存储其历史版本。通常，版本信息会包含事务ID和时间戳等元数据，用于标识和区分不同版本的数据。
2. **快照读（Snapshot Read）**：读操作不会阻塞写操作。每次读取数据时，系统会生成一个一致性快照，读操作基于该快照读取数据。这保证了读操作在事务开始时看到的视图是一致的，即使其他事务进行了修改。
3. **版本链**：每个数据行维护一个版本链，链表中每个节点代表数据行的一个版本。最新的版本在链表的头部，历史版本按时间顺序排列。

#### MVCC 的实现细节

以 InnoDB 为例，InnoDB 是 MySQL 中默认的存储引擎，并且使用 MVCC 来实现事务隔离。以下是 InnoDB 中 MVCC 的实现细节：

##### 1. 隐藏列

InnoDB 为每行数据添加了两个隐藏列：

- `DB_TRX_ID`：记录最后修改该行的事务ID。
- `DB_ROLL_PTR`：指向回滚段，用于存储修改前的旧版本数据。

当事务修改一行数据时，会创建一个新的版本，同时更新这两个隐藏列。

##### 2. Undo Log

Undo Log 用于记录数据修改前的旧版本。当事务进行回滚时，可以通过 Undo Log 恢复到旧版本。Undo Log 还用于读取历史版本的数据。

##### 3. Read View

每个事务在开始时，会创建一个一致性视图（Read View），该视图包含当前活跃事务的快照。Read View 用于决定一个数据版本是否对当前事务可见。

##### 4. 可见性判断

当事务读取数据时，根据 Read View 判断数据版本的可见性：

- 如果数据行的 `DB_TRX_ID` 小于 Read View 中的最小活跃事务ID，则该版本对当前事务可见。
- 如果数据行的 `DB_TRX_ID` 大于 Read View 中的最大活跃事务ID，则该版本对当前事务不可见。
- 如果数据行的 `DB_TRX_ID` 在 Read View 的活跃事务ID列表中，则该版本对当前事务不可见。

#### MVCC 的优点

1. 高并发性能：读操作不会阻塞写操作，写操作也不会阻塞读操作，极大地提高了系统的并发性能。
2. 一致性视图：每个事务在开始时获取一致性视图，确保事务在读取数据时看到的视图是一致的，即使其他事务进行了修改。
3. 减少锁竞争：通过多版本管理，减少了读写操作之间的锁竞争，避免了许多因锁争用而导致的性能问题。

#### MVCC 的缺点

1. 存储开销：由于需要维护多个版本的数据，MVCC 需要更多的存储空间。数据行的历史版本和 Undo Log 都会占用额外的存储空间。
2. 版本清理：需要定期清理无用的历史版本，以防止存储空间的无限增长。这通常通过垃圾回收机制实现。

### 10、MVCC 解决了哪些问题？

1. **读-写冲突**：在传统的并发控制机制中，读操作和写操作之间存在冲突，读操作会阻塞写操作，写操作会阻塞读操作，降低了系统的并发性能。MVCC 通过维护数据的多个版本，使得读操作不会被写操作阻塞，读操作可以读取到一个一致性的快照，提高了系统的并发性能。
2. **写-写冲突**：在传统的并发控制机制中，两个事务同时对同一数据进行写操作时会发生冲突，其中一个事务的写操作会被阻塞，直到另一个事务完成。MVCC 通过维护数据的多个版本，每个事务可以看到自己修改的数据版本，不会被其他事务的写操作阻塞，提高了系统的并发性能。
3. **不可重复读**：不可重复读是指在一个事务中，同一查询在不同时间点多次执行，返回的结果不一致。MVCC 通过事务开始时创建一致性快照（Read View），保证了在同一事务中多次读取同一数据的结果是一致的，解决了不可重复读的问题。
4. **幻读**：幻读是指在一个事务中，同一查询在不同时间点多次执行，返回的结果集不一致，可能包含了其他事务插入或删除的数据。MVCC 通过维护数据的多个版本，保证了在同一事务中多次执行相同查询返回的结果是一致的，解决了幻读的问题。
5. **并发性能**：MVCC 提高了系统的并发性能，通过允许读操作不会被写操作阻塞，写操作也不会被读操作阻塞，减少了锁的竞争，提高了系统的并发处理能力。

### 11、MVCC 机制如何解决幻读？介绍一下MySQL中的锁机制，说一下间隙锁的使用及原理

MVCC（多版本并发控制）机制通过维护数据的多个版本来解决幻读问题。在MVCC中，每个事务在开始时会创建一个一致性视图（Read View），该视图包含了事务开始时数据库中所有数据的一个快照。在事务执行期间，所有的读操作都基于这个一致性视图，从而保证了事务读取数据的一致性。

对于幻读问题，MVCC主要通过在读操作中使用快照读（Snapshot Read）来解决。快照读意味着在事务开始时生成一个一致性快照，事务中的所有读操作都基于这个快照进行，而不受其他事务并发修改的影响。因此，即使其他事务在事务执行期间插入或删除数据，当前事务也不会受到影响，从而避免了幻读问题。

在MySQL中，除了MVCC机制外，还有锁机制用于并发控制。MySQL中的锁主要分为两种：行级锁和表级锁。行级锁用于控制对数据行的访问，而表级锁用于控制对整个表的访问。

#### 行级锁

行级锁是在数据行级别上加锁，可以避免多个事务同时修改同一行数据而导致的冲突。MySQL中的InnoDB存储引擎默认使用行级锁来实现MVCC机制。行级锁包括如下几种类型：

1. **共享锁（Shared Lock）**：允许事务读取一行数据，但不允许对其进行修改。多个事务可以同时持有共享锁，但不允许有其他事务持有排他锁。
2. **排他锁（Exclusive Lock）**：允许事务对一行数据进行读取和修改。排他锁不能与其他锁共存，即排他锁会阻止其他事务获取任何类型的锁。

#### 表级锁

表级锁是对整个表加锁，可以控制对整个表的访问。MySQL中的表级锁包括如下几种类型：

1. **表共享锁（Table Read Lock）**：多个事务可以同时获取表共享锁，用于阻止其他事务获取排他锁，但不阻止其他事务获取表共享锁。
2. **表排他锁（Table Write Lock）**：只允许一个事务获取表排他锁，其他事务不能同时获取任何类型的锁。

#### 间隙锁（Gap Lock）

间隙锁是InnoDB存储引擎特有的一种锁机制，用于解决幻读问题。间隙锁是在索引记录之间的间隙上设置的锁，用于防止其他事务在这个间隙内插入新记录，从而避免了幻读问题。

间隙锁的使用和原理如下：

1. **使用**：当一个事务执行范围查询（例如：SELECT ... WHERE id BETWEEN 10 AND 20）时，InnoDB会在查询的索引范围内的间隙上设置间隙锁，阻止其他事务在这个间隙内插入新记录。
2. **原理**：间隙锁是排他锁的一种，它的目的是为了防止其他事务在查询的索引范围内插入新记录，从而保证了范围查询的结果是一致的，避免了幻读问题。



### 12、索引如何优化？

### 13、说一下 select、poll、epoll

### 14、poll 和 epoll 的使用场景

### 15、输入 URL 后发生的事情

### 16、HTTP 基于什么协议实现？

### 17、如何使用 HTTP 协议与服务器连接（TCP三次握手）

### 18、HTTP 和 HTTPS 的区别？

### 19、HTTPS 如何确保安全性？

### 20、为什么不能只使用非对称加密？

### 21、说一下 CA 证书

### 22、CA证书是由谁传输的？

### 23、如何使用 CA 证书（CA 证书是如何保证安全的）？

### 24、如果访问两个不同的网站，如何获取 CA 的公钥？

### 25、手撕算法：无重复字符的最长子串