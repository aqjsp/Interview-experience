# 腾讯微信部门C++开发实习一面

## C++

### 1、多态靠什么机制实现的?

1. 静态多态（编译时多态，也称为早绑定或函数重载）：静态多态（编译期多态）的主要实现方式有函数重载和模板。函数重载是指在同一作用域内定义多个同名函数，但参数列表不同，由编译器根据参数类型和数量确定调用哪个函数。而模板是在编译时根据模板参数的类型生成具体的代码，实现对不同类型的参数进行相同操作的函数或类。

```
#include <iostream>

void print(int value) {
    std::cout << "Integer value: " << value << std::endl;
}

void print(double value) {
    std::cout << "Double value: " << value << std::endl;
}

int main() {
    print(10);
    print(3.14);
    return 0;
}
```

2. 动态多态（运行时多态，也称为晚绑定或虚函数）：在运行时根据对象的实际类型来确定调用的函数或方法。动态多态是通过虚函数（virtual function）和继承（inheritance）实现的。在动态多态中，基类的指针或引用可以指向派生类的对象，并且通过这个指针或引用调用的虚函数会根据对象的实际类型来确定调用哪个版本的函数，这种机制称为动态绑定。动态多态的一个特点是可以实现运行时的多态性，即在运行时才确定调用的函数版本。

```
#include <iostream>

class Base {
public:
    virtual void print() {
        std::cout << "Base class" << std::endl;
    }
};

class Derived : public Base {
public:
    void print() override {
        std::cout << "Derived class" << std::endl;
    }
};

int main() {
    Base* basePtr = new Derived();
    basePtr->print();  // 输出 "Derived class"
    delete basePtr;
    return 0;
}
```

### 2、多态内部通过什么实现的?

参考1。

### 3、什么是纯虚函数?

纯虚函数是在基类中声明的虚函数，但没有在基类中给出具体的实现，它只是一个接口，需要在派生类中进行实现。纯虚函数通过在函数声明后面加上 `= 0` 来声明。一个类中只要有一个纯虚函数，就成为了抽象类，抽象类不能实例化对象，只能作为基类被继承。

纯虚函数的作用：

1. 提供接口规范：通过纯虚函数，基类可以定义一组接口规范，要求派生类必须实现这些接口，从而保证派生类具有某种特定的行为或功能。
2. 实现多态：纯虚函数和虚函数一样，支持运行时的多态性。在运行时，根据对象的实际类型调用相应的函数。

参考代码：

```
#include <iostream>

// 抽象类
class Shape {
public:
    // 纯虚函数，提供接口规范
    virtual double area() const = 0;
    virtual void draw() const = 0;
};

// 派生类，实现了 Shape 接口
class Circle : public Shape {
public:
    Circle(double r) : radius(r) {}
    double area() const override {
        return 3.14 * radius * radius;
    }
    void draw() const override {
        std::cout << "Drawing circle" << std::endl;
    }

private:
    double radius;
};

// 派生类，实现了 Shape 接口
class Rectangle : public Shape {
public:
    Rectangle(double w, double h) : width(w), height(h) {}
    double area() const override {
        return width * height;
    }
    void draw() const override {
        std::cout << "Drawing rectangle" << std::endl;
    }

private:
    double width;
    double height;
};

int main() {
    Circle c(5);
    Rectangle r(3, 4);

    // 通过指向基类的指针实现多态
    Shape* shapePtr1 = &c;
    Shape* shapePtr2 = &r;

    std::cout << "Circle area: " << shapePtr1->area() << std::endl;
    std::cout << "Rectangle area: " << shapePtr2->area() << std::endl;

    shapePtr1->draw();
    shapePtr2->draw();

    return 0;
}
```

### 4、用过lambda表达式吗? 能否写一个?

Lambda表达式是C++11引入的一种函数对象，可以用来创建匿名函数。它的基本语法如下：

```
[capture list](parameters) -> return_type { body }
```

其中：

- `capture list`：捕获列表，用来捕获外部变量。可以是值捕获（`[=]`）、引用捕获（`[&]`）或特定变量的捕获（`[x, &y]`）等方式。
- `parameters`：参数列表，与普通函数的参数列表类似。
- `return_type`：返回类型，可以省略，由编译器推导出来。
- `body`：函数体，与普通函数的函数体类似。

给个例子：

```
#include <iostream>

int main() {
    int a = 5;
    int b = 10;

    // Lambda表达式，求两个数的和
    auto sum = [](int x, int y) -> int {
        return x + y;
    };

    std::cout << "Sum of " << a << " and " << b << " is " << sum(a, b) << std::endl;

    return 0;
}
```

Lambda表达式也可以捕获外部变量。

```
#include <iostream>

int main() {
    int a = 5;
    int b = 10;

    // Lambda表达式，捕获外部变量a，求和
    auto sum_with_capture = [a](int x) -> int {
        return a + x;
    };

    std::cout << "Sum of " << a << " and 7 is " << sum_with_capture(7) << std::endl;

    return 0;
}
```

### 5、Linux中进程内存布局知道吗?

1. 栈：栈是用于存储函数的局部变量和函数调用信息的内存区域。每当调用一个函数，系统会为其分配一个栈帧，包含局部变量和函数参数。当函数执行完毕，栈帧被弹出，释放相关内存。栈的分配和释放速度很快，但大小通常受限于系统。
2. 堆：堆是用于动态内存分配的区域，通常由开发人员手动分配和释放。堆上的内存需要手动管理，因此需要小心避免内存泄漏和悬挂指针问题。堆的大小通常比栈大，但分配和释放速度较慢。
3. 全局/静态存储区：这是用于存储全局变量和静态变量的区域。全局变量是在程序启动时创建的，持续到程序结束，而静态变量在它们首次访问时初始化，然后保持其值在函数调用之间保持不变。
4.  自由存储区：就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。
5. 常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改（当然，你要通过非正当手段也可以修改，而且方法很多）

### 6、各个分区存放哪些数据?

1. 栈（Stack）：存放函数的局部变量、函数参数值、返回地址等信息。栈是一种后进先出（LIFO）的数据结构，函数调用时会分配栈帧，在函数返回时释放栈帧。因此，栈上的数据的生命周期与函数的调用关系密切。栈空间通常较小，大小受限于系统，但分配和释放速度快。
2. 堆（Heap）：堆用于动态分配内存，存放动态分配的变量和对象。堆上的内存需要手动管理，使用malloc、new等函数分配内存，使用free、delete等函数释放内存。堆的大小通常比栈大，但分配和释放速度较慢。
3. 全局/静态存储区（Global/Static Storage）：全局变量和静态变量存放在这个区域。全局变量在程序启动时创建，持续到程序结束，静态变量在首次访问时初始化，然后保持其值在函数调用之间保持不变。
4. 自由存储区（Free Store）：也是用于动态分配内存的区域，类似于堆。它是通过`malloc`、`calloc`等函数分配的内存块，需要通过`free`、`delete`等函数释放。
5. 常量存储区（Constant Storage）：存放常量数据，如字符串常量、全局常量等。这些数据通常在编译时就确定，并且不允许修改。常量存储区通常位于只读内存中，尝试修改这些数据会导致程序崩溃。

### 7、临时变量是存在哪里的?

1. 函数内部的临时变量：在函数内部声明的临时变量通常存储在栈上。当函数调用时，会为这些临时变量分配内存，当函数返回时，这些临时变量所占用的内存会被释放。
2. 表达式中的临时变量：在表达式计算过程中产生的临时变量通常存储在寄存器中，这样可以提高计算速度。对于无法存储在寄存器中的较大的临时变量，可能会存储在栈上。
3. 全局临时变量：如果临时变量是全局的，则存储在静态存储区。这些变量在程序运行期间一直存在，不会随着函数的调用而分配和释放。

### 8、在堆上分配内存，在C++中怎么去申请?

1. 使用`new`申请内存：`new`关键字用于在堆上动态分配内存，语法如下：

   ```
   int* ptr = new int; // 分配一个整型变量的内存空间
   ```

   例子中，`new int`将返回一个指向动态分配的整型变量的指针，并将该指针赋值给`ptr`变量。如果需要分配的是数组，可以使用如下语法：

   ```
   int* arr = new int[10]; // 分配一个包含10个整型元素的数组的内存空间
   ```

2. 使用`delete`释放内存：使用`new`分配的内存需要手动释放，否则会导致内存泄漏。可以使用`delete`关键字来释放内存，语法如下：

   ```
   delete ptr; // 释放ptr指向的内存空间
   ```

   如果分配的是数组，需要使用`delete[]`释放内存：

   ```
   delete[] arr; // 释放arr指向的数组内存空间
   ```

   需要注意的是，释放内存后，指针将变为悬空指针，应该将其设置为`nullptr`以避免误用。

### 9、假如现在一个数据量比较大，比如达到兆级，一般放在哪里?

1. 硬盘: 对于大量数据，最常见的存储位置是硬盘。硬盘有较大的存储容量，可以持久保存数据，但读写速度相对较慢，适合存储不经常访问的数据。
2. 内存: 如果数据量不是特别大，但又需要快速访问，可以将数据存储在内存中。内存读写速度非常快，适合存储需要频繁访问的数据，但内存容量有限，无法存储过大的数据。
3. 数据库: 对于需要结构化存储和管理的数据，可以将数据存储在数据库中。数据库可以是关系型数据库（如MySQL、PostgreSQL）或非关系型数据库（如MongoDB、Redis），具体选择根据数据特点和访问需求而定。
4. 分布式存储系统: 对于大规模数据存储和处理，可以使用分布式存储系统，如Hadoop的HDFS、Apache Cassandra、Amazon S3等。这些系统可以横向扩展，适合存储PB级别甚至更大规模的数据。
5. 缓存: 对于需要频繁访问的数据，可以使用缓存来提高访问速度。常见的缓存系统包括Redis、Memcached等，它们通常将数据存储在内存中，提供快速的读写访问。

### 10、C++没有内存回收，C++中分配内存要考虑到什么问题?

1. 内存泄漏：分配了内存但没有释放，导致程序运行时内存不断累积，最终可能耗尽可用内存。解决方法是在不需要使用内存时及时释放。
2. 重复释放：对同一块内存多次释放会导致程序崩溃或不可预测的行为。解决方法是避免重复释放同一块内存。
3. 野指针：指向已释放内存的指针称为野指针，访问野指针会导致程序崩溃或不可预测的行为。解决方法是在释放内存后将指针置为nullptr。
4. 内存越界：访问超出分配内存范围的内存会导致程序崩溃或不可预测的行为。解决方法是确保访问的内存范围不超出分配的范围。
5. 内存对齐：某些平台要求内存按照一定的字节对齐方式分配，不正确的内存对齐可能导致性能问题或程序崩溃。解决方法是根据平台要求正确对齐内存。
6. 内存拷贝：在使用动态内存分配时，需要注意拷贝指针指向的内存而不是指针本身，否则可能导致两个指针指向同一块内存，释放时会出错。
7. 内存分配效率：频繁的内存分配和释放会影响程序性能，可以通过对象池、内存池等方式提高内存分配效率。
8. 异常安全：在分配内存时要考虑异常安全，即当内存分配失败时程序能够正常处理，避免资源泄漏。

### 11、避免内存泄漏的方法有哪些?

1. 手动释放内存：在动态分配内存后，确保在不再需要使用时及时释放。使用`delete`或`delete[]`释放对应的内存。
2. 使用智能指针：使用智能指针管理动态分配的内存，可以避免忘记释放内存的问题。C++11引入的`std::shared_ptr`和`std::unique_ptr`是两种常用的智能指针，它们会在对象不再需要时自动释放内存。
3. 避免循环引用：如果使用`std::shared_ptr`管理对象，要注意避免循环引用，即两个对象互相持有对方的`shared_ptr`，导致对象无法释放。
4. RAII（资源获取即初始化）：使用RAII管理资源，即在对象构造时分配资源，在对象析构时释放资源。通过RAII，可以确保资源在对象不再需要时被正确释放。
5. 内存检测工具：使用内存检测工具（如Valgrind、Dr.Memory等）来检测内存泄漏问题，及时发现并修复潜在的内存泄漏。

### 12、在使用过程中主动释放，但是很难避免程序在运行过程中中途退出的情况，内存也会泄漏，那有没有其他更好的方式避免内存泄漏?

1. 避免使用裸指针：尽量避免使用裸指针进行内存管理，因为裸指针容易导致内存泄漏和悬挂指针问题。可以使用智能指针或其他更安全的内存管理方式代替裸指针。
2. 使用内存池/对象池：可以使用内存池或对象池来管理对象的内存分配和释放，从而减少动态内存分配和释放的次数，降低内存泄漏的风险。

### 13、智能指针是用什么方式避免内存泄漏的?

1. 自动释放内存：智能指针通过在析构函数中释放内存来确保内存被正确释放。当智能指针指向的对象不再被引用时，智能指针对象会自动调用析构函数，从而释放内存。
2. 引用计数：智能指针通常使用引用计数来跟踪对象的引用次数。每次创建一个指向对象的智能指针时，引用计数加一；每次销毁一个指向对象的智能指针时，引用计数减一。当引用计数为零时，说明没有任何指针指向该对象，此时会自动释放对象的内存。
3. 避免悬挂指针：智能指针可以防止悬挂指针问题的发生。当对象被释放后，智能指针会自动将指针置为nullptr，从而避免了访问已释放对象的问题。
4. 管理数组内存：C++11引入的std::unique_ptr和std::shared_ptr可以用于管理动态数组的内存。智能指针可以确保在释放数组内存时调用delete[]而不是delete。
5. 异常安全性：智能指针提供了异常安全性，即使在发生异常时，智能指针也可以正确地释放内存，避免内存泄漏。

## 操作系统

### 1、进程间的通信方式有哪些?

1. 管道（Pipe）：管道是一种半双工的通信方式，用于具有亲缘关系的进程之间的通信。在Linux中，管道可以是匿名管道（通过pipe函数创建）或命名管道（通过mkfifo函数创建）。管道有一定的缓冲区，可以在一端写入数据，在另一端读取数据。
2. 命名管道（Named Pipe）：也称为FIFO（First In First Out），是一种特殊的文件类型，用于不具有亲缘关系的进程之间的通信。命名管道在文件系统中有一个路径名，进程可以通过文件I/O操作来进行通信。
3. 消息队列（Message Queue）：消息队列是一种消息传递机制，允许进程通过将消息发送到队列中来进行通信。消息队列通常具有特定的格式和优先级，可以实现进程间的异步通信。
4. 信号量（Semaphore）：信号量是一种用于控制对共享资源访问的机制。进程可以通过对信号量进行操作来实现对共享资源的互斥访问和同步。
5. 共享内存（Shared Memory）：共享内存是一种高效的进程间通信方式，允许多个进程共享同一块内存区域。通过共享内存，进程可以直接读写共享数据，而无需进行数据拷贝，因此可以实现较高的通信速度。
6. 套接字（Socket）：套接字是一种网络编程接口，可以用于不同主机上的进程间通信，也可以用于同一主机上的进程间通信。套接字通信可以在网络上进行，也可以在同一台计算机上进行本地通信。

### 2、多个线程间的有哪些通信方式?

### 3、Linux下查看Linux服务器的性能指标通过什么查看?比如内存、CPU使用情况

### 4、别人作为客户端给Linux服务器上的程序发消息，但是你这边没收到，Linux下面用什么方式命令可以快速知道这个包有没有到你这边?

### 5、调试程序有BUG是通过什么方式调试的?

## 计算机网络

### 1、5层网络协议是哪5层

### 2、TCP属于哪一层?

### 3、数据链路层通过什么来寻址?

### 4、网络层通过什么来寻址?

### 5、不在同一局域网的两台机器，分别只有IP，在客户端发出消息到服务端收到地址，经过哪些协议?

### 6、包到达路由器下的局域网了，拿到的只是一个IP，在局域网下面怎么把IP换成MAC的?

### 7、ARP协议的流程是什么?

### 8、socket编程，TCP和UDP在API层面主要有哪些区别?

### 9、TCP是可靠传输，我们在编程的时候相比UDP是不是要绑定端口这些?

### 10、网络多路复用里，什么是IO多路复用?

### 11、经常说大端小端，网络通信是属于大端还是小端?

### 12、HTTP里面的返回码知道吗? 200代表什么?

### 13、如果要把状态码区分为客户端还是服务端的问题，你觉得客户端问题的返回码主要是什么，以哪些开头的返回码是客户端的问题?

## 数据库

### 1、数据库中要优化查询性能，最常见的方式是什么?

### 2、数据库索引是干什么用的?

### 3、索引是通过什么数据结构实现的知道吗?

### 4、快排的时间复杂度是多少?

### 5、常用的负载均衡协议有了解吗?

### 6、一次性哈希听过没有?

## 编程题

### ATOI函数，将字符串转化成数字？

问: 什么时候可以开始实习，可以实习多久?
反问
1.部门具体干什么的?
2.部门员工需要掌握哪些方面的知识?