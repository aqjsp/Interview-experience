# 未岚大陆秋招C++一面

> 来源：https://www.nowcoder.com/discuss/680756488276553728

### 1、fork和exec是怎么实现的？ 

#### 1. `fork` 系统调用

`fork` 系统调用用于创建一个新的进程，这个新进程被称为子进程，而调用 `fork` 的进程被称为父进程。子进程是父进程的一个副本，但在某些方面有所不同，比如进程 ID（PID）。

##### 实现步骤

1. 分配新的进程资源：
   - 内核为子进程分配新的进程控制块（PCB），包括进程 ID、状态、优先级等。
   - 分配新的内存空间，包括代码段、数据段、堆栈段等。
2. 复制父进程的资源：
   - 复制父进程的 PCB 信息，但更新子进程的 PID。
   - 复制父进程的代码段、数据段和堆栈段。现代操作系统通常使用 **写时复制（Copy-On-Write, COW）** 技术来优化这个过程。初始时，父进程和子进程共享相同的内存页面，只有当其中一个进程尝试写入某一页时，内核才会为该页创建一个副本。
   - 复制父进程的文件描述符表，使子进程继承父进程打开的文件。
3. 设置子进程的状态：
   - 将子进程的状态设置为就绪态，准备被调度执行。
   - 设置子进程的初始指令指针，使其从 `fork` 调用返回后继续执行。
4. 返回值：
   - `fork` 调用在父进程中返回子进程的 PID。
   - `fork` 调用在子进程中返回 0。
   - 如果 `fork` 调用失败，返回 -1，并设置 `errno` 以指示错误原因。

##### 代码示例

```c
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>

int main() {
    pid_t pid = fork();

    if (pid < 0) {
        fprintf(stderr, "Fork failed\n");
        return 1;
    } else if (pid == 0) {
        // 子进程
        printf("I am child, my pid is %d\n", getpid());
    } else {
        // 父进程
        printf("I am father, my pid is %d, child pid is %d\n", getpid(), pid);
    }

    return 0;
}
```

#### 2. `exec` 系统调用

`exec` 系列函数用于在当前进程中加载并执行新的程序，用新的程序替换当前进程的内存映像。`exec` 系列函数有多种变体，包括 `execl`、`execv`、`execle`、`execve`、`execlp` 和 `execvp`，它们的主要区别在于参数的传递方式和环境变量的处理。

##### 实现步骤

1. 加载新的程序：
   - 内核释放当前进程的代码段、数据段和堆栈段。
   - 从指定的路径加载新的程序的二进制文件。
   - 将新的程序的代码段、数据段和堆栈段加载到内存中。
2. 设置新的程序的入口点：
   - 将新的程序的入口点（通常是 `main` 函数）设置为当前进程的指令指针。
   - 设置新的程序的参数和环境变量。
3. 返回值：
   - `exec` 系列函数成功调用后不会返回，因为当前进程已经被新的程序替换。
   - 如果 `exec` 调用失败，返回 -1，并设置 `errno` 以指示错误原因。

##### 代码示例

```c
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>

int main() {
    pid_t pid = fork();

    if (pid < 0) {
        fprintf(stderr, "Fork failed\n");
        return 1;
    } else if (pid == 0) {
        // 子进程
        char *args[] = {"/bin/ls", "-l", NULL};
        execv("/bin/ls", args);

        // 如果 execv 失败，会返回到这里
        fprintf(stderr, "Exec failed\n");
        return 1;
    } else {
        // 父进程
        printf("I am father, my pid is %d, child pid is %d\n", getpid(), pid);
    }

    return 0;
}
```

### 2、select、poll、epoll的区别？LT和ET的区别？

#### 1. `select` 机制

`select` 是最早的I/O多路复用机制之一，几乎在所有的Unix系统上都有实现。它允许一个进程监视多个文件描述符，等待这些描述符中的任何一个变为可读、可写或发生异常。

##### 主要特点

- 文件描述符限制：`select` 有一个固定的文件描述符限制，通常是1024个。这个限制可以通过修改内核参数来增加，但依然存在。
- 轮询机制：`select` 采用轮询的方式，每次调用 `select` 时，都需要将所有感兴趣的文件描述符集合从用户态复制到内核态，并在内核态中逐个检查这些文件描述符的状态。
- 返回值：`select` 返回后，会修改传入的文件描述符集合，将所有就绪的文件描述符标记出来。应用程序需要遍历这些集合，找到所有就绪的文件描述符。

##### 优点

- 可移植性：`select` 几乎在所有的Unix系统上都有实现，具有很好的可移植性。
- 简单易用：`select` 的使用相对简单，易于理解和实现。

##### 缺点

- 性能问题：随着文件描述符数量的增加，`select` 的性能会显著下降，因为每次调用都需要遍历所有文件描述符。
- 文件描述符限制：`select` 的文件描述符限制较低，不适合处理大量文件描述符的场景。

#### 2. `poll` 机制

`poll` 是对 `select` 的改进，解决了 `select` 的一些局限性，尤其是在文件描述符数量上的限制。

##### 主要特点

- 无文件描述符限制：`poll` 没有文件描述符数量的限制，因为它使用链表来存储文件描述符，可以动态扩展。
- 轮询机制：`poll` 仍然采用轮询的方式，每次调用 `poll` 时，都需要将所有感兴趣的文件描述符集合从用户态复制到内核态，并在内核态中逐个检查这些文件描述符的状态。
- 返回值：`poll` 返回后，会修改传入的 `pollfd` 结构体数组，将所有就绪的文件描述符标记出来。应用程序需要遍历这些结构体，找到所有就绪的文件描述符。

##### 优点

- 无文件描述符限制：`poll` 可以处理更多的文件描述符，适用于大规模并发场景。
- 简单易用：`poll` 的使用相对简单，易于理解和实现。

##### 缺点

- 性能问题：尽管 `poll` 解决了文件描述符数量的限制，但其轮询机制仍然会导致性能下降，特别是当文件描述符数量较多时。

#### 3. `epoll` 机制

`epoll` 是Linux特有的I/O多路复用机制，设计目的是解决 `select` 和 `poll` 在处理大量文件描述符时的性能问题。

##### 主要特点

- 事件驱动：`epoll` 采用事件驱动的方式，只有当文件描述符准备好时，内核才会通知应用程序。这避免了轮询机制的性能开销。
- 无文件描述符限制：`epoll` 没有文件描述符数量的限制，可以处理大量的文件描述符。
- 内存映射：`epoll` 使用内存映射技术，减少了文件描述符在用户态和内核态之间的复制开销。
- 回调机制：`epoll` 为每个文件描述符注册了回调函数，当文件描述符准备好时，内核会调用这些回调函数，将就绪的文件描述符加入就绪队列中。

##### 优点

- 高性能：`epoll` 的事件驱动机制使得它在处理大量文件描述符时性能优越。
- 无文件描述符限制：`epoll` 可以处理大量的文件描述符，适用于高并发场景。
- 内存映射：`epoll` 使用内存映射技术，减少了文件描述符在用户态和内核态之间的复制开销。

##### 缺点

- 复杂性：`epoll` 的使用相对复杂，需要更多的系统调用和数据结构管理。
- 平台限制：`epoll` 是Linux特有的机制，不具有跨平台的特性。

##### 水平触发（LT）

- 触发条件：只要文件描述符处于就绪状态，`epoll_wait` 就会返回。
- 特点：如果应用程序在 `epoll_wait` 返回后没有处理完所有就绪的文件描述符，下次调用 `epoll_wait` 时，这些文件描述符仍然会被返回。
- 适用场景：适用于需要精确控制的场景，例如处理少量数据或需要确保数据完整性的场景。

##### 边缘触发（ET）

- 触发条件：只有当文件描述符从非就绪状态变为就绪状态时，`epoll_wait` 才会返回。
- 特点：如果应用程序在 `epoll_wait` 返回后没有处理完所有就绪的文件描述符，下次调用 `epoll_wait` 时，这些文件描述符不会再次被返回，除非文件描述符的状态再次发生变化。
- 适用场景：适用于高并发、高吞吐量的场景，例如处理大量数据流的场景。ET模式要求应用程序在 `epoll_wait` 返回后立即处理所有就绪的文件描述符，否则可能会遗漏事件。

### 3、如何判断一个任务处理完成？

这里给大家列举两个比较常用的，需要了解更多，可自行学习。

#### 1. 使用 `std::condition_variable`

`std::condition_variable` 是C++标准库中用于线程间同步的工具。它允许一个线程等待某个条件变为真，而另一个线程在满足条件时通知等待的线程。

##### 实现步骤

1. 定义条件变量和互斥量：定义一个 `std::condition_variable` 和一个 `std::mutex`。
2. 设置条件：在任务完成时，设置一个共享的条件变量。
3. 等待条件：在主线程中使用 `std::condition_variable` 等待条件变为真。

##### 代码示例

```c
#include <iostream>
#include <thread>
#include <condition_variable>
#include <mutex>

std::condition_variable cv;
std::mutex mtx;
bool task_completed = false;

void task_with_condition_variable() {
    std::this_thread::sleep_for(std::chrono::seconds(2));
    std::cout << "任务完成" << std::endl;
    {
        std::lock_guard<std::mutex> lock(mtx);
        task_completed = true;
    }
    cv.notify_one();  // 通知等待的线程
}

int main() {
    std::thread t(task_with_condition_variable);

    std::unique_lock<std::mutex> lock(mtx);
    cv.wait(lock, [] { return task_completed; });  // 等待任务完成

    std::cout << "所有任务执行完成" << std::endl;

    t.join();
    return 0;
}
```

#### 2. 使用 `std::atomic` 变量

`std::atomic` 变量提供了原子操作，可以用于在多线程环境中安全地共享数据。通过设置一个 `std::atomic` 变量来表示任务的状态，主线程可以检查这个变量来判断任务是否完成。

##### 实现步骤

1. 定义 `std::atomic` 变量：定义一个 `std::atomic<bool>` 变量来表示任务的状态。
2. 设置任务状态：在任务完成时，设置 `std::atomic` 变量。
3. 检查任务状态：在主线程中检查 `std::atomic` 变量的值。

##### 代码示例

```c
#include <iostream>
#include <thread>
#include <atomic>

std::atomic<bool> task_completed(false);

void task_with_atomic() {
    std::this_thread::sleep_for(std::chrono::seconds(2));
    std::cout << "任务完成" << std::endl;
    task_completed = true;  // 设置任务完成
}

int main() {
    std::thread t(task_with_atomic);

    while (!task_completed.load()) {
        std::this_thread::yield();  // 让出CPU时间片
    }

    std::cout << "所有任务执行完成" << std::endl;

    t.join();
    return 0;
}
```

### 4、进程和线程的区别？

#### 1. 资源分配

- 进程：进程是操作系统中资源分配的基本单位。每个进程都有独立的地址空间、内存空间、文件描述符等资源。进程之间的资源是隔离的，一个进程的资源不会直接影响到另一个进程。
- 线程：线程是CPU调度的基本单位，但线程不拥有系统资源。线程是进程中的一个执行单元，同一进程中的多个线程共享进程的资源，如内存、文件描述符等。线程之间的资源共享使得线程之间的通信更为方便。

#### 2. 地址空间

- 进程：每个进程都有独立的地址空间。这意味着每个进程都有自己的虚拟地址空间，包括代码段、数据段、堆和栈。
- 线程：同一进程中的所有线程共享同一个地址空间。这意味着线程可以访问进程中的任何数据，但不能访问其他进程的数据。

#### 3. 通信

- 进程：进程之间的通信需要通过进程间通信（IPC）机制，如管道、消息队列、共享内存、信号量等。这些机制通常涉及到额外的系统调用和开销。
- 线程：同一进程中的线程可以直接访问共享的内存空间，因此线程之间的通信更为高效。线程可以通过共享变量、互斥锁等机制进行同步和通信。

#### 4. 调度

- 进程：在传统的操作系统中，进程是调度的基本单位。进程的调度涉及到更多的系统开销，因为需要保存和恢复进程的上下文。
- 线程：在引入线程的操作系统中，线程是调度的基本单位。线程的调度开销较小，因为线程只需要保存和恢复少量的寄存器和栈信息。

#### 5. 系统开销

- 进程：创建和销毁进程的开销较大。操作系统需要为每个进程分配和回收资源，如内存、文件描述符等。进程切换时也需要保存和恢复大量的上下文信息。
- 线程：创建和销毁线程的开销较小。操作系统只需要为线程分配少量的资源，如栈空间和寄存器。线程切换时的开销也较小，因为只需要保存和恢复少量的寄存器和栈信息。

#### 6. 并发性

- 进程：进程之间的并发性较低，因为进程之间的资源是隔离的，通信开销较大。
- 线程：线程之间的并发性较高，因为线程共享进程的资源，通信开销较小。同一进程中的多个线程可以并发执行，提高系统的吞吐量。

#### 7. 稳定性和安全性

- 进程：多进程程序更稳定，因为进程之间的资源是隔离的。一个进程的崩溃不会影响其他进程。
- 线程：多线程程序的稳定性较差，因为线程共享资源，一个线程的错误可能导致整个进程崩溃。

### 5、线程独有的资源是什么？





### 6、读写锁什么时候上锁？ 

### 7、什么是死锁？只有两个线程时候，会发生死锁吗？

### 8、栈和堆的区别？

### 9、讲一下智能指针，各自的区别？

### 10、弱引用计数的来源？

### 11、了解make_shared吗？weak_ptr会导致线程不安全吗？

### 12、讲一些stl中的容器和各自特点？

### 13、讲一下deque的底层实现？

### 14、红黑树的特点？哈希表的特点？如何解决哈希冲突？

### 15、讲一下右值引用？

### 16、什么时候使用移动语义？

### 17、讲一下多态？怎么调用虚函数的？

### 18、手撕，题目是 力**28. 最长连续序列