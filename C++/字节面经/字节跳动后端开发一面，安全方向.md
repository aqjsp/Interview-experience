# 字节跳动后端开发一面

> 来源：https://www.nowcoder.com/discuss/550639195967000576

### 1、数据库性能很差，可能是什么原因？怎么排查？

1. 查询语句效率低下：检查数据库的查询语句，确保它们被正确优化。使用数据库查询分析工具，如`EXPLAIN`（MySQL）、SQL Server Profiler（SQL Server）或pg_stat_statements（PostgreSQL），来分析查询计划和性能。
2. 索引问题：确保数据库表使用了合适的索引。缺少必要的索引或使用了不必要的索引可能导致性能下降。可以使用数据库的索引优化工具或查询执行计划来检查索引的使用情况。
3. 锁问题：长时间的数据库锁会影响性能。检查是否有锁冲突或锁等待。数据库管理系统通常提供了锁等待和锁监控工具，可以用来排查这些问题。
4. 硬件资源不足：如果数据库服务器的硬件资源（CPU、内存、磁盘）不足，性能将受到限制。使用性能监控工具来检查服务器的资源利用情况。
5. 缓存问题：数据库缓存不足或失效会导致频繁的磁盘读取，从而影响性能。确保数据库的缓存设置合理，如MySQL的`key_buffer_size`或PostgreSQL的`shared_buffers`。
6. 慢查询：定期监控和识别慢查询，使用数据库日志或监控工具，然后优化这些查询。可以考虑使用数据库性能分析工具，如pt-query-digest，来分析慢查询。
7. 数据量过大：如果数据量过大，可能会导致性能下降。考虑数据分区、归档或清理过期数据等策略来处理大数据量。

### 2、MySQL怎么去选择索引的？

1. 根据查询需求选择索引类型：

   - 主键索引：每个表都应该有一个主键索引，通常是自增主键。

   - 唯一索引：适用于需要唯一性约束的列。

   - 组合索引：使用多个列来创建索引以支持多条件的查询。但要小心组合索引的列数，不要过度索引，以免影响性能。

2. 考虑查询的频率：

   - 针对经常使用的查询条件创建索引，以提高这些查询的性能。

   - 避免为不经常使用的条件创建过多索引，因为每个索引都需要维护，会增加写操作的开销。

3. 评估选择的索引对性能的影响：

   - 使用`EXPLAIN`来分析查询执行计划，查看MySQL如何使用索引来处理查询。

   - 比较不同索引的性能，查看查询的执行时间和资源占用情况。

4. 考虑数据类型：

使用适当的数据类型来定义列，以减小索引的大小，提高性能。

5. 索引字段的顺序：

对于组合索引，选择合适的字段顺序，以支持最常见的查询条件。

6. 确保数据完整性：

对于唯一索引，确保数据的完整性以避免违反唯一性约束。

### 3、成本是怎么定义的？构建索引的最佳实践有哪些？

在数据库性能优化中，成本通常是指执行一个查询或操作所需的资源和时间消耗。成本的定义和评估是通过数据库查询执行计划、性能分析和监测来进行的。

给大家看看一些用于定义成本的指标：

1. 查询执行时间： 成本的一个关键指标是执行查询所需的时间。这通常是通过分析实际查询的执行时间来确定的。
2. CPU 利用率： 查询执行期间 CPU 的利用率是一个关键指标。高 CPU 利用率通常表示较高的成本，因为查询执行可能需要较多的 CPU 计算资源。
3. 磁盘 I/O： 磁盘读取和写入是数据库操作中潜在的高成本操作之一。对于查询来说，需要从磁盘读取数据通常比从内存读取数据成本更高。
4. 内存消耗： 内存的使用情况对数据库性能和成本也有重要影响。如果查询需要大量内存，可能会导致内存不足，触发交换操作，降低性能。
5. 锁定和等待： 数据库中的锁定和等待操作也可能导致较高的成本。长时间的等待和竞争锁定可能影响查询性能。
6. 网络带宽： 对于分布式数据库，网络带宽也是一个重要的成本因素。查询的结果传输可能会消耗大量带宽。
7. 资源争夺： 多个查询或操作可能会争夺数据库系统中的共享资源，如 CPU、磁盘、内存等，导致性能下降。
8. 数据库服务器负载： 成本还取决于数据库服务器的负载情况。高负载时，查询可能会等待资源，导致成本增加。

最佳实践：

1. 选择合适的列进行索引： 不是所有列都需要建立索引。选择那些经常用于查询和筛选的列。通常，主键列和经常在`WHERE`子句、`JOIN`操作或`ORDER BY`子句中使用的列是索引的候选项。
2. 使用唯一索引： 当需要确保某一列的唯一性时，使用唯一索引。这有助于防止重复数据的插入。
3. 选择适当的索引类型： 根据查询需求选择合适的索引类型。常见的索引类型包括单列索引、组合索引、全文本索引、空间索引等。
4. 不要过度索引： 过多的索引可能会导致维护成本增加，对写操作性能产生不利影响。只建立必要的索引，避免过度索引。
5. 定期重建和优化索引： 随着数据库的使用，索引会产生碎片并降低性能。定期执行索引重建和优化操作，以确保索引保持高效。
6. 使用前缀索引： 对于文本列，可以考虑使用前缀索引，以减小索引大小，提高查询性能。
7. 注意索引顺序： 对于组合索引，索引列的顺序很重要。将最常用于查询的列放在索引前面，以提高性能。
8. 监控索引性能： 使用数据库性能监控工具，定期检查索引的性能。根据实际查询和负载情况，可能需要调整索引策略。
9. 避免在索引列上进行大量计算： 避免在索引列上执行函数或计算，因为这会导致索引失效。
10. 使用索引提示： 在某些情况下，数据库优化器可能无法正确选择索引。在这种情况下，可以使用索引提示来强制选择特定的索引。
11. 合理使用覆盖索引： 覆盖索引是包含了查询所需的列的索引。这可以减少从磁盘读取的数据量，提高查询性能。
12. 了解数据库的特性： 不同的数据库管理系统有不同的索引实现和特性。了解你所使用的数据库的特性，以更好地构建索引。
13. 与查询优化器合作： 与数据库查询优化器一起工作，通过分析查询执行计划来了解索引的使用情况，进行性能调优。

### 4、写一个SQL：

有一张学生表，表里面有学生id，和若干个课程的成绩，输出平均分不及格的所有学生。

假设学生表是`students`，其中包括学生的学生ID（student_id）和不同课程的成绩。给个参考SQL语句：

```sql
SELECT student_id
FROM students
GROUP BY student_id
HAVING AVG(grade) < 60;
```

### 5、C++多态？

多态性是指同一个操作可以作用于不同类型的对象，并且可以根据对象的类型执行不同的行为。多态性通过虚函数和函数重载实现。

- 编译时多态性（静态多态性）： 通过函数重载实现，编译器在编译时根据函数参数的类型和数量来选择调用合适的函数。这种多态性是在编译时解析的。
- 运行时多态性（动态多态性）： 通过虚函数和继承实现，允许在运行时根据对象的实际类型来调用适当的函数。这种多态性是在运行时解析的。

### 6、虚函数怎么实现的？具体是怎么动态派发到不同虚函数上的？

C++中的虚函数通过虚函数表（vtable）来实现动态派发。虚函数表是一个特殊的数据结构，它包含了指向各个虚函数的指针。每个包含虚函数的类都会有一个虚函数表，其中的每个指针指向对应虚函数的地址。

具体步骤：

1. 定义一个基类，并在其中声明虚函数。虚函数通常使用 `virtual` 关键字来声明。

```C++
class Base {
public:
    virtual void someFunction() {
        // 基类的虚函数
    }
};
```

2. 创建派生类，并在其中重写基类的虚函数。

```C++
class Derived : public Base {
public:
    void someFunction() override {
        // 派生类的虚函数，覆盖了基类的虚函数
    }
};
```

3. 在运行时，当调用一个虚函数时，实际调用的函数是根据对象的类型来动态决定的。这是通过虚函数表来实现的。每个对象都包含一个指向其虚函数表的指针。

4. 当调用虚函数时，编译器会根据对象的虚函数指针查找虚函数表，然后使用表中的指针来调用适当的虚函数。

### 7、你怎么知道这个虚函数调用的时候是编译器填充好了数组下标，怎么验证的？

编译器通常会为每个类生成一个虚函数表（vtable），这个虚函数表是一个函数指针数组，用于存储虚函数的地址。每个虚函数在虚函数表中都有一个对应的槽位，槽位的顺序通常与虚函数在类中的声明顺序一致。

当一个对象调用虚函数时，编译器并不是在运行时动态查找虚函数的地址，而是通过对象的虚函数指针指向相应的虚函数表。虚函数指针在对象的内存布局中通常是一个指向虚函数表的指针。这个虚函数指针被创建和初始化在对象构造时。

在编译器看来，调用虚函数的过程类似于以下伪代码：

```C++
object->vptr[index_of_virtual_function]()
```

其中，`object` 是指向对象的指针，`vptr` 是虚函数指针，`index_of_virtual_function` 是虚函数在虚函数表中的槽位索引。

要知道编译器如何填充虚函数表的槽位，可以使用调试器查看对象的内存布局，包括虚函数指针和虚函数表的内容。这样你可以验证编译器是否正确地为每个虚函数生成对应的槽位，并填充了正确的函数指针。

### 8、如果一个子类继承了两个父类，有几个虚函数表？父类拥有同名的虚函数是怎么处理的？

当一个子类继承了两个父类（多重继承）时，子类将包含两个或更多的虚函数表，一个对应于每个父类。每个虚函数表将包含相应父类的虚函数。

如果两个或多个父类具有同名的虚函数，这将导致二义性。在这种情况下，C++编译器通常不会自动解决冲突。子类必须提供自己的版本或重写虚函数来明确指定应该调用哪个父类的虚函数。

下面是一个示例，说明了多重继承中同名虚函数的处理：

```C++
#include <iostream>

class Base1 {
public:
    virtual void foo() {
        std::cout << "Base1::foo()" << std::endl;
    }
};

class Base2 {
public:
    virtual void foo() {
        std::cout << "Base2::foo()" << std::endl;
    }
};

class Derived : public Base1, public Base2 {
public:
    // You need to override the foo() function to disambiguate
    void foo() {
        Base1::foo(); // Explicitly call Base1's version of foo
        Base2::foo(); // Explicitly call Base2's version of foo
    }
};

int main() {
    Derived derived;
    derived.foo(); // Calls Derived's foo which calls both Base1's and Base2's foo
    return 0;
}
```

### 9、深拷贝和浅拷贝？A = B是深拷贝还是浅拷贝？func(A a)是深拷贝还是浅拷贝？

浅拷贝：浅拷贝会复制对象的引用，而不会复制对象本身的内容。这意味着新对象和原对象将引用相同的数据，因此它们之间的改变会相互影响。如果你对新对象做了修改，原对象也会受到影响，反之亦然。在浅拷贝中，只有对象引用被复制，而不是对象的内容。

```C++
A = B;  // 浅拷贝，A 和 B 引用相同的数据
func(A a);  // 传递对象 a 也是浅拷贝
```

深拷贝：深拷贝会复制对象本身的内容，而不会与原对象共享数据。这意味着新对象是一个完全独立的副本，对新对象的修改不会影响原对象，反之亦然。在深拷贝中，对象的所有数据都会被复制，包括它所引用的其他对象。

```C++
A = DeepCopy(B);  // 深拷贝，A 和 B 是独立的对象
func(A a);  // 传递对象 a 也是深拷贝
```

### 10、ps命令能看到哪些信息？ls命令呢？

`ps` 命令是 "进程状态" 的缩写，它用于查看有关正在运行的进程的信息。

`ps` 命令能够看到的一些信息：

- 进程的状态和运行时间。
- 进程的ID（PID）和父进程的ID（PPID）。
- 进程的资源使用情况，如CPU和内存占用情况。
- 进程的命令行参数。
- 用户和用户组信息。
- 终端信息，如果进程在终端上运行。

`ls` 命令用于列出文件和目录。它可以显示文件和目录的名称，权限，大小，时间戳等信息。

`ls` 命令可以看到的信息：

- 文件和目录的名称。
- 文件和目录的权限。
- 文件大小。
- 文件的创建时间或最后修改时间。
- 文件类型（普通文件、目录、符号链接等）。

### 12、文件的权限有哪些？目录的读写执行权限代表什么意思？

在Unix/Linux系统中，文件和目录的权限由文件权限模式（File Permission Mode）来控制，通常以三组字符表示，每组字符代表不同的用户类型。每组字符包含三个权限位，分别用于读取、写入和执行。

1. 文件权限（针对普通文件）：
   - "r" 表示读取权限，允许用户查看文件内容。
   - "w" 表示写入权限，允许用户修改文件内容。
   - "x" 表示执行权限，允许用户执行文件作为可执行程序。
   - "-" 表示没有相应的权限。
2. 目录权限（针对目录）：
   - "r" 表示读取权限，允许用户列出目录中的文件和子目录。
   - "w" 表示写入权限，允许用户创建、删除或重命名目录中的文件和子目录。
   - "x" 表示执行权限，允许用户进入目录。
   - "-" 表示没有相应的权限。

文件和目录的权限字符按照用户类型，通常分为三组：

1. 用户权限（Owner Permissions）：这些权限适用于文件或目录的所有者。
2. 组权限（Group Permissions）：这些权限适用于文件或目录所属的用户组。
3. 其他权限（Others Permissions）：这些权限适用于所有其他用户。

例如，对于一个文件，权限字符串可能是 `rw-r--r--`，它表示：

- 文件的所有者（用户）有读写权限。
- 文件所属的用户组有只读权限。
- 所有其他用户只有只读权限。

对于一个目录，权限字符串可能是 `rwxr-x---`，它表示：

- 目录的所有者（用户）有读、写、执行权限。
- 文件所属的用户组有读和执行权限，但没有写入权限。
- 所有其他用户没有任何权限。

### 13、TCP报文的flag知道哪些？

1. URG：紧急标志位。用于指示数据中包含紧急数据。与紧急指针字段一起使用，通常用于通知接收方应该优先处理这部分数据。
2. ACK：确认标志位。用于指示TCP报文中的确认号字段是否有效。如果ACK标志被设置，那么确认号字段包含了期望的下一个序列号。通常用于确认已经收到了数据。
3. PSH：推送标志位。用于告知接收方在接收到这个TCP报文后立即将数据传递给应用层，而不需要等待缓冲区满了再传递。
4. RST：重置连接标志位。用于终止一个TCP连接。通常用于处理异常情况，例如连接中断或无效连接尝试。
5. SYN：同步标志位。用于建立一个新的TCP连接。通常在连接的初始阶段使用，用于协商初始序列号等参数。
6. FIN：结束标志位。用于终止一个TCP连接。通常在连接的关闭阶段使用，通知对方不再发送数据。

### 14、socket连接一个未启动的服务器端口会产生什么情况？socket返回的错误码是什么？

当你尝试使用Socket连接到一个未启动的服务器端口时，会发生连接失败的情况。这通常会导致一个错误码，通常是"Connection Refused"（连接被拒绝）。在不同的编程语言和操作系统中，错误码可能会有所不同，但一般情况下，你可以期望得到一种类似的错误。

在C/C++的Socket编程中，你可以使用`errno`变量来获取最后一次发生的错误代码。在连接被拒绝的情况下，通常`errno`的值会被设置为`ECONNREFUSED`，其值通常是11。这个错误表示连接尝试被服务器拒绝。

### 15、HTTP协议的流程？单指应用层的流程。

1. 建立连接：客户端（通常是Web浏览器）向服务器发起连接请求。这个连接通常是基于TCP/IP协议的。客户端使用标准端口80（HTTP）或443（HTTPS）发起连接。
2. 请求：客户端向服务器发送HTTP请求。这个请求通常包括以下内容：
   - HTTP方法（GET、POST、PUT、DELETE等）：定义对资源的操作。
   - URL（Uniform Resource Locator）：指定要访问的资源的地址。
   - 头部信息：包括请求的主机、客户端的信息、接受的数据格式等。
   - 消息体（对于POST请求）：如果需要向服务器发送数据，数据将包含在请求消息体中。
3. 服务器处理：服务器接收到HTTP请求后，会根据请求中的信息和服务器上的资源来处理请求。这可能涉及到从数据库检索数据、生成动态内容、访问文件系统等。
4. 响应：服务器会生成HTTP响应，该响应包括以下内容：
   - 状态码：指示请求是否成功，或是否发生了错误。
   - 头部信息：包括响应的日期、服务器信息、响应的数据格式等。
   - 消息体：包含实际的响应数据，例如HTML文档、图像、文本等。
5. 传输数据：服务器将HTTP响应发送回客户端，通常是作为HTTP响应包。这是通过之前建立的TCP连接来完成的。
6. 渲染页面：客户端接收到HTTP响应后，会解析响应的数据并在Web浏览器中呈现。这可能包括渲染HTML、JavaScript执行、加载图像和其他媒体等。
7. 断开连接：一旦响应数据传输完毕，连接可以被断开，尤其对于非持久性连接。客户端和服务器都可以选择关闭连接，或者在需要时保持连接以获取其他资源。