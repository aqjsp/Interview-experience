来源：https://www.nowcoder.com/feed/main/detail/fc4a48403b534aafa6a6bce14b542c4e?sourceSSR=search

1、智能指针？

1. `std::shared_ptr`：

   - 原理：`std::shared_ptr`是基于引用计数的智能指针，用于管理动态分配的对象。它维护一个引用计数，当计数为零时，释放对象的内存。

   - 使用场景：适用于多个智能指针需要共享同一块内存的情况。例如，在多个对象之间共享某个资源或数据。

   - ```C++
     std::shared_ptr<int> sharedInt = std::make_shared<int>(42);
     std::shared_ptr<int> anotherSharedInt = sharedInt; // 共享同一块内存
     ```

2. `std::unique_ptr`：

   - 原理：`std::unique_ptr`是独占式智能指针，意味着它独占拥有所管理的对象，当其生命周期结束时，对象会被自动销毁。

   - 使用场景：适用于不需要多个指针共享同一块内存的情况，即单一所有权。通常用于资源管理，例如动态分配的对象或文件句柄。

   - ```C++
     std::unique_ptr<int> uniqueInt = std::make_unique<int>(42);
     // uniqueInt 的所有权是唯一的
     ```

3. `std::weak_ptr`：

   - 原理：`std::weak_ptr`是一种弱引用指针，它不增加引用计数。它通常用于协助`std::shared_ptr`，以避免循环引用问题。

   - 使用场景：适用于协助解决`std::shared_ptr`的循环引用问题，其中多个`shared_ptr`互相引用，导致内存泄漏。

   - ```C++
     std::shared_ptr<int> sharedInt = std::make_shared<int>(42);
     std::weak_ptr<int> weakInt = sharedInt;
     ```

4. `std::auto_ptr`（已废弃）：

   - 原理：`std::auto_ptr`是C++98标准引入的智能指针，用于独占地管理对象。但由于其存在潜在的问题，已在C++11中被废弃。

   - 使用场景：在C++98标准中，可用于独占性地管理动态分配的对象。不推荐在现代C++中使用。

   - ```C++
     std::auto_ptr<int> autoInt(new int(42)); // 已废弃
     ```

2、栈和堆的区别？

1. 分配方式:
   - 栈：栈是一种自动分配和释放内存的数据结构，它遵循"后进先出"（LIFO）原则。当你声明一个局部变量时，该变量存储在栈上。函数的参数和局部变量也存储在栈上。栈的分配和释放是自动的，由编译器管理。
   - 堆：堆是一种手动分配和释放内存的数据结构。在堆上分配内存需要使用`new`或`malloc`等函数，释放内存则需要使用`delete`或`free`。堆上的内存不会自动释放，必须手动管理。
2. 存储内容:
   - 栈：栈主要存储局部变量、函数参数和函数调用的上下文。它的存储生命周期通常是有限的，当超出其作用域时，内存会自动释放。
   - 堆：堆主要用于存储动态分配的对象和数据结构。它的存储生命周期没有那么明确，需要手动释放。
3. 生命周期:
   - 栈：栈上的变量生命周期与其作用域（通常是一个函数的执行）相对应。一旦超出作用域，栈上的变量将自动销毁。
   - 堆：堆上的内存生命周期由程序员控制。在程序员显式释放内存之前，内存将一直存在。
4. 分配速度:
   - 栈：由于栈上的内存分配和释放是自动管理的，通常比堆更快。
   - 堆：堆上的内存分配和释放需要较多的开销，通常比较慢。
5. 大小限制:
   - 栈：栈的大小通常受到限制，因为它由操作系统管理，可以很小，通常在几MB以内。
   - 堆：堆的大小可以较大，受到系统资源的限制，通常比栈要大得多。
6. 数据访问:
   - 栈：栈上的数据访问速度较快，因为它是线性存储，访问局部变量通常只需要一次寻址操作。
   - 堆：堆上的数据访问速度较慢，因为它是散乱存储，需要进行额外的寻址操作。

3、c++和c的不同？

- C是面向过程的语言，而C++是面向对象的语言。
- C和C++动态管理内存的方法不一样，C是使用malloc/free函数，而C++除此之外还使用new/delete关键字。
- C++的类是C里没有的，但是C中的struct是可以在C++中正常使用的，并且C++对struct进行了进一步的扩展，使得struct在C++中可以和class有一样的作用。而唯一和class不同的地方在于struct成员默认访问修饰符是public，而class默认的是private。
- C++支持重载，而C语言不支持。
- C++有引用，C没有。
- C++全部变量的默认链接属性是外链接，而C是内链接。
- C 中用const修饰的变量不可以用在定义数组时的大小，但是C++用const修饰的变量可以。

4、用const的目的？

1. 防止修改变量的值： 将变量声明为 `const` 后，编译器会确保该变量的值在初始化后不能被修改。这有助于在程序中创建更加稳定和可维护的代码。

```C++
const int maxAttempts = 3;
// maxAttempts = 4;  // 错误，无法修改常量
```

2. 指定函数参数为只读： 在函数定义中，使用 `const` 可以指定某个参数是只读的，防止在函数内部修改参数的值。

```C++
void printMessage(const std::string& message) {
    // message += "!";  // 错误，无法修改只读参数
    std::cout << message << std::endl;
}
```

3. 确保成员函数不修改对象状态： 在成员函数声明和定义中使用 `const` 关键字，可以确保该成员函数不会修改调用对象的状态。这种方法被称为常量成员函数。

```C++
class MyClass {
public:
    void modifyState();          // 普通成员函数
    void queryState() const;     // 常量成员函数，不修改对象状态
};
```

4. 指定常量指针或常量引用： 在指针或引用声明中使用 `const` 可以指定指针指向的对象是常量，或者引用的对象是常量。

```C++
const intptrToConst;  // 指向常量的指针
int constconstPtr;    // 同样是指向常量的指针
```

5. 避免不必要的拷贝： 在函数参数传递和返回值中使用 `const` 可以避免不必要的拷贝，提高性能。

5、指针和数组的区别？

- 概念

数组：存储连续多个相同类型的数据；

指针：变量，存的是地址

- 赋值

同类型的指针变量可以相互赋值，数组不行，只能一个一个元素的赋值或拷贝

- 存储方式

数组：连续内存空间。

指针：灵活，可以指向任意类型的数据。指向的是地址空间的内存。

- sizeof

数组的sizeof求的是占用的空间（字节）。

在32位平台下，无论指针的类型是什么，sizeof（指针名）都是4；在64位平台下，无论指针的类型是什么，sizeof（指针名）都是8。

- 传参

作为参数时，数组名退化为常量指针。

6、重载和重写的区别？

重载（Overloading）：

- 定义：在同一个作用域内，允许存在多个同名的函数，但是这些函数的参数列表必须不同（包括参数的个数、类型、顺序等）。
- 目的：通过相同的函数名来处理不同类型的参数，提高代码的灵活性。
- 发生条件：函数名相同，但参数列表不同。

```C++
int add(int a, int b) {
    return a + b;
}

double add(double a, double b) {
    return a + b;
}
```

重写（Overriding）：

- 定义： 在派生类中重新实现（覆盖）其基类的虚函数。发生在继承关系中，子类重新定义基类的虚函数，实现子类自己的版本。
- 目的： 支持多态性，允许基类的指针或引用在运行时指向派生类对象，并调用相应的派生类函数。
- 发生条件： 子类继承自父类，子类中的函数与父类中的虚函数具有相同的函数签名。

```C++
class Shape {
public:
    virtual void draw() const {
        // 具体的实现
    }
};

class Circle : public Shape {
public:
    void draw() const override {
        // Circle 版本的实现，覆盖了基类的虚函数
    }
};
```

总结：

- 重载是指在同一作用域中定义多个同名函数，通过参数列表的不同来区分；
- 重写是指派生类重新实现（覆盖）其基类的虚函数，以支持多态性。

7、定义指针时要注意的问题？

1. 初始化：指针在定义时最好立即初始化，可以为其赋予 `nullptr`（C++11 及以上）或 `NULL`，或者指向有效的内存地址。未初始化的指针具有不确定的值。

```C++
int* ptr = nullptr; // 推荐使用 nullptr 初始化指针
```

2. 悬空指针：当指针指向的内存被释放后，如果不将指针置为 `nullptr`，该指针就成了悬空指针。使用悬空指针可能导致未定义行为。

```C++
int* ptr = new int;
delete ptr;
// ptr 现在是悬空指针
```

3. 野指针： 指针指向未知的内存地址，可能是未初始化的指针或者指向已释放的内存。使用野指针可能导致程序崩溃或不可预测的行为。

```C++
int* ptr; // 未初始化的指针
*ptr = 42; // 野指针
```

4. 空指针解引用：尝试解引用空指针会导致未定义行为。在解引用指针之前，应该确保指针不为 `nullptr`。

```C++
int* ptr = nullptr;
// *ptr; // 错误，解引用空指针
```

5. 指针的生命周期：指针在超出其作用域后不再有效，但如果指针指向的是动态分配的内存，需要手动释放以防止内存泄漏。

```C++
void foo() {
    int* ptr = new int;
    // 使用 ptr
    delete ptr; // 释放动态分配的内存
} // ptr 超出作用域，但内存已经释放
```

6. 指向栈上的内存：当指针指向栈上的内存时，应该确保在指针超出作用域之前，该内存仍然有效。

```C++
int* func() {
    int x = 42;
    return &x; // 错误，返回指向栈上的内存地址
} // x 超出作用域，指向的内存已经无效
```

7. 空指针与野指针： 空指针（`nullptr`）表示指针不指向任何有效的内存地址，而野指针是指指针的值是一个不确定的地址。合理使用空指针，并尽量避免野指针。

8、c++内存分配？

1. 栈区（Stack）：用于存储局部变量和函数调用的信息。栈是一种后进先出（LIFO）的数据结构。每当进入一个新的函数，系统会为其分配一个栈帧，用于存储局部变量、参数和函数调用的返回地址等信息。当函数执行完成，对应的栈帧会被销毁。
2. 堆区（Heap）：用于动态分配内存。程序员通过`new`运算符从堆上分配内存，通过`delete`运算符释放堆上的内存。堆上的内存分配和释放需要程序员手动管理，确保在不再使用时及时释放，以防止内存泄漏。
3. 全局区/静态区（Global/Static Area）：用于存储全局变量和静态变量。全局变量存储在全局数据区，静态变量存储在静态数据区。这些变量在程序启动时被分配，直到程序结束时才会释放。
4. 常量区（Constant Area）：用于存储常量字符串和全局常量。这部分内存是只读的，程序运行期间不能修改。
5. 代码区（Code Area）：用于存储程序的执行代码。在程序运行时，代码区是只读的。

9、new/delete和malloc/free的联系及区别？

`new` 和 `delete` 是 C++ 中用于动态内存分配和释放的运算符，而 `malloc` 和 `free` 是 C 语言中对应的库函数。

联系：

1. 目的相同： `new` 和 `malloc` 都用于在堆上动态分配内存，而 `delete` 和 `free` 用于释放动态分配的内存。
2. 使用方式： `new` 和 `delete` 是 C++ 中的运算符，可以直接使用，而 `malloc` 和 `free` 是 C 语言中的库函数，需要包含头文件 `<cstdlib>`。

区别：

1. 类型安全： `new` 和 `delete` 是类型安全的，它们会调用对象的构造函数和析构函数。`malloc` 和 `free` 是基于 `void*`，不会调用构造和析构函数，因此不是类型安全的。
2. 大小参数： `new` 和 `delete` 不需要显式指定要分配的内存大小，它们会根据类型自动计算。而 `malloc` 和 `free` 需要显式指定分配或释放的内存大小。
3. 操作对象： `new` 和 `delete` 主要用于操作对象，而 `malloc` 和 `free` 可以用于分配任意大小的内存块。
4. 对NULL的处理： `new` 在分配失败时会抛出 `std::bad_alloc` 异常，而 `malloc` 在分配失败时返回 `NULL`。
5. 适用范围： `new` 和 `delete` 是 C++ 中的运算符，而 `malloc` 和 `free` 是 C 标准库中的函数。在 C++ 中，推荐使用 `new` 和 `delete`，因为它们更符合面向对象的编程思想。

10、c++是类型安全的语言吗（面试官提到了动态联编和静态联编）？

C++ 是一种相对而言更加类型安全的编程语言。类型安全是指在编译时和运行时，程序对数据类型的使用都是合法的，不会发生未定义行为。C++ 在设计上考虑了类型安全，并提供了一些机制来减少类型相关的错误。

1. 静态联编（Static Binding）：在编译阶段，编译器将函数调用与具体的函数实现关联起来，这被称为静态联编。C++ 是静态类型语言，因此大部分的联编工作在编译时完成。这有助于在编译期发现一些类型相关的错误，提高了类型安全性。
2. 动态联编（Dynamic Binding）：在运行时，通过虚函数和多态性实现动态联编。C++ 支持运行时多态，允许在父类的指针或引用上调用子类的虚函数。这种机制在一定程度上提高了灵活性，但也引入了动态联编的概念。
3. 强类型：C++ 是一种强类型的语言，即在编译时对类型的检查比较严格，不同类型之间的操作需要进行明确的类型转换。
4. 静态类型检查：C++ 是一种静态类型检查语言，这意味着变量的类型在编译时就已经确定，不会发生隐式的类型转换错误。
5. 面向对象的封装：C++ 支持面向对象编程，通过类的封装特性可以将数据和操作封装在一起，防止未授权的访问和修改。
6. 模板和泛型编程：C++ 提供了模板和泛型编程的支持，允许程序员编写与类型无关的代码，提高了代码的通用性和类型安全性。

11、main函数前会有其他函数语句被执行吗？ 在标准的 C++ 程序中，`main`函数是程序的入口点，程序从`main`函数开始执行。在`main`函数执行之前，不会有其他普通函数被自动调用。然而，有一些特殊情况可能导致`main`函数执行前调用其他函数或执行其他代码。

1. 全局对象的构造：在 C++ 中，全局变量和静态变量的构造函数会在`main`函数执行之前调用。这意味着如果你有全局对象，它们的构造函数将在`main`函数执行前执行。

```C++
#include <iostream>

class GlobalObject {
public:
    GlobalObject() {
        std::cout << "GlobalObject constructed!" << std::endl;
    }
};

GlobalObject globalVar;  // 全局变量，构造函数会在 main 函数执行前调用

int main() {
    std::cout << "Inside main function!" << std::endl;
    return 0;
}
```

例子中，`GlobalObject` 类的构造函数会在 `main` 函数执行前被调用。

2. 特殊初始化函数：在一些特殊的嵌入式系统或特定编译器中，可能存在一些特殊的初始化函数，这些函数可能在 `main` 函数之前执行。

12、虚函数实现？

1. 虚函数表（vtable）：对于每个包含虚函数的类，编译器会在该类的对象中添加一个指向虚函数表的指针。虚函数表是一个数组，其中存储了类的虚函数的地址。每个类有一个对应的虚函数表。
2. 虚函数指针（vptr）：对象中的虚函数指针指向虚函数表。在对象的构造过程中，虚函数指针被设置为指向类的虚函数表。
3. 动态绑定：当通过基类指针或引用调用虚函数时，实际调用的是对象的实际类型的虚函数。这种调用方式被称为动态绑定。编译器通过虚函数指针找到对象的虚函数表，然后在表中查找对应虚函数的地址。

看个例子：

```C++
#include <iostream>

class Base {
public:
    virtual void show() {
        std::cout << "Base::show()" << std::endl;
    }
};

class Derived : public Base {
public:
    void show() override {
        std::cout << "Derived::show()" << std::endl;
    }
};

int main() {
    Base baseObj;
    Derived derivedObj;

    Base* basePtr = &baseObj;
    Base* derivedPtr = &derivedObj;

    // 调用虚函数，实际执行 Derived::show()
    basePtr->show();
    derivedPtr->show();

    return 0;
}
```

例子中，`Base` 类有一个虚函数 `show`，而 `Derived` 类覆盖了这个虚函数。在 `main` 函数中，通过基类指针调用虚函数，实际执行的是对象的实际类型的虚函数。这就是虚函数实现动态绑定的基本原理。

13、TLS握手？

1. 客户端向服务端发起第一次握手请求，告诉服务端客户端所支持的SSL的指定版本、加密算法及密钥长度等信息。
2. 服务端将自己的公钥发给数字证书认证机构，数字证书认证机构利用自己的私钥对服务器的公钥进行数字签名，并给服务器颁发公钥证书。
3. 服务端将证书发给客户端。
4. 客服端利用数字认证机构的公钥，向数字证书认证机构验证公钥证书上的数字签名，确认服务器公开密钥的真实性。
5. 客户端使用服务端的公开密钥加密自己生成的对称密钥，发给服务端。
6. 服务端收到后利用私钥解密信息，获得客户端发来的对称密钥。
7. 通信双方可用对称密钥来加密解密信息。

流程图如下：

![image-20231220001045731](E:\GitHub\Interview-experience\阿里面经\assets\image-20231220001045731.png)

14、手撕算法冒泡排序

基本思想是通过重复遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就交换它们，直到没有需要交换的元素为止。

思路：

1. 从第一个元素开始，依次比较相邻的两个元素。
2. 如果顺序不对，就交换这两个元素的位置。
3. 继续遍历整个数组，执行相同的操作。
4. 一轮遍历结束后，最大的元素就会沉到数组末尾。
5. 重复上述步骤，但不包括已经排序好的元素，直到整个数组有序。

参考代码：

```C++
#include <iostream>
#include <vector>

void bubbleSort(std::vector<int>& arr) {
    int n = arr.size();

    for (int i = 0; i < n - 1; ++i) {
        // 每一轮遍历，把最大的元素放到末尾
        for (int j = 0; j < n - i - 1; ++j) {
            // 如果前面的元素比后面的大，交换它们的位置
            if (arr[j] > arr[j + 1]) {
                std::swap(arr[j], arr[j + 1]);
            }
        }
    }
}

int main() {
    // 测试数据
    std::vector<int> arr = {64, 34, 25, 12, 22, 11, 90};

    // 打印排序前的数组
    std::cout << "排序前的数组：";
    for (int num : arr) {
        std::cout << num << " ";
    }

    // 调用冒泡排序函数
    bubbleSort(arr);

    // 打印排序后的数组
    std::cout << "\n排序后的数组：";
    for (int num : arr) {
        std::cout << num << " ";
    }

    return 0;
}
```

了解了一些密码学的相关知识，后面就属于聊天了。面试官依旧人很好，给予了很积极的反馈，说了一下笔试的问题，给了一些建议。